/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#include <Python.h>               
#include "pygobject.h"
#include "gvareatool.h"
#include "gvdata.h"
#include "gview.h"
#include "gvlayer.h"
#include "gvlinetool.h"
#include "gvmanager.h"
#include "gvmesh.h"
#include "gvnodetool.h"
#include "gvpointtool.h"
#include "gvpoitool.h"
#include "gvproperties.h"
#include "gvraster.h"
#include "gvrasterlayer.h"
#include "gvrecttool.h"
#include "gvroitool.h"
#include "gvrotatetool.h"
#include "gvselecttool.h"
#include "gvshapelayer.h"
#include "gvshapes.h"
#include "gvshapeslayer.h"
#include "gvsymbolmanager.h"
#include "gvtool.h"
#include "gvtoolbox.h"
#include "gvutils.h"
#include "gvtracktool.h"
#include "gvviewarea.h"
#include "gvviewlink.h"
#include "gvzoompantool.h"
#include "gv-enum-types.h"
#include "gv_override.h"
#include "invdistance.h"
#include "gv_ciet.h"

%%
modulename _gv
%%
import gtk.DrawingArea as PyGtkDrawingArea_Type
import gtk.Button as PyGtkButton_Type
import gtk.Object as PyGtkObject_Type
import gtk.Adjustment as PyGtkAdjustment_Type
import gobject.GObject as PyGObject_Type
import gtk.Widget as PyGtkWidget_Type

%%
ignore-glob
  *_get_type
  gv_mesh_*
%%
ignore
  gv_data_get_memento
  gv_data_set_memento
  gv_data_del_memento
  gv_raster_pixel_to_georefCL
  gv_raster_georef_to_pixelCL
  gv_shapes_add_shape
  gv_shapes_add_shape_last

%%
include
  gvshape.override
%%
define GvViewArea.get_width noargs
static PyObject *
_wrap_gv_view_area_get_width(PyGObject *self)
{
    return PyInt_FromLong(gv_view_area_get_width(GV_VIEW_AREA(self->obj)));
}
%%
define GvViewArea.get_height noargs
static PyObject *
_wrap_gv_view_area_get_height(PyGObject *self)
{
    return PyInt_FromLong(gv_view_area_get_height(GV_VIEW_AREA(self->obj)));
}
%%
override gv_view_area_zoom
static PyObject *
_wrap_gv_view_area_zoom(PyGObject *self, PyObject *args)
{
    double zoom;

    if (!PyArg_ParseTuple(args, "d:GvViewArea.zoom", &zoom))
        return NULL;

    gv_view_area_zoom(GV_VIEW_AREA(self->obj), zoom);

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gv_view_area_get_zoom
static PyObject *
_wrap_gv_view_area_get_zoom(PyGObject *self)
{
    return PyFloat_FromDouble(gv_view_area_get_zoom(GV_VIEW_AREA(self->obj)));
}
%%
override gv_view_area_rotate
static PyObject *
_wrap_gv_view_area_rotate(PyGObject *self, PyObject *args)
{
    double angle;

    if (!PyArg_ParseTuple(args, "d:GvViewArea.rotate", &angle))
        return NULL;

    gv_view_area_rotate(GV_VIEW_AREA(self->obj), angle);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_translate
static PyObject *
_wrap_gv_view_area_translate(PyGObject *self, PyObject *args)
{
    double dx, dy;

    if (!PyArg_ParseTuple(args, "dd:GvViewArea.translate", &dx, &dy))
        return NULL;

    gv_view_area_translate(GV_VIEW_AREA(self->obj), dx, dy);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_set_translation
static PyObject *
_wrap_gv_view_area_set_translation(PyGObject *self, PyObject *args)
{
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:GvViewArea.set_translation", &x, &y))
        return NULL;

    gv_view_area_set_translation(GV_VIEW_AREA(self->obj), x, y);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_fit_extents
static PyObject *
_wrap_gv_view_area_fit_extents(PyGObject *self, PyObject *args)
{
    double llx, llyy, width, height;

    if (!PyArg_ParseTuple(args, "dddd:GvViewArea.fit_extents", &llx, &llyy, &width, &height))
        return NULL;

    gv_view_area_fit_extents(GV_VIEW_AREA(self->obj), llx, llyy, width, height);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_height_scale
static PyObject *
_wrap_gv_view_area_height_scale(PyGObject *self, PyObject *args)
{
    double scale;

    if (!PyArg_ParseTuple(args, "d:GvViewArea.height_scale", &scale))
        return NULL;

    gv_view_area_height_scale(GV_VIEW_AREA(self->obj), scale);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_get_height_scale noargs
static PyObject *
_wrap_gv_view_area_get_height_scale(PyGObject *self)
{
    return PyFloat_FromDouble(gv_view_area_get_height_scale(GV_VIEW_AREA(self->obj)));
}
%%
override gv_view_area_remove_layer
static PyObject *
_wrap_gv_view_area_remove_layer(PyGObject *self, PyObject *args)
{
    PyGObject *layer;

    if (!PyArg_ParseTuple(args, "O!:GvViewArea.remove_layer", &PyGObject_Type, &layer))
        return NULL;
    
    gv_view_area_remove_layer(GV_VIEW_AREA(self->obj), G_OBJECT(layer->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_list_layers noargs
static PyObject *
_wrap_gv_view_area_list_layers(PyGObject *self)
{
    PyObject *py_list;
    GvViewArea *view;
    GList *list;

    view = GV_VIEW_AREA(self->obj);

    py_list = PyList_New(0);
    for (list = gv_view_area_list_layers(view); list != NULL; list = list->next)
    {
        PyObject *layer = pygobject_new(G_OBJECT(list->data));
        PyList_Append(py_list, layer);
        Py_DECREF(layer);
    }

    g_list_free(list);
    return py_list;
}
%%
define GvViewArea.get_translation noargs
static PyObject *
_wrap_gv_view_area_get_translation(PyGObject *self)
{
    GvViewArea *view = GV_VIEW_AREA(self->obj);

    return Py_BuildValue( "(" CC ")", view->state.tx, view->state.ty );
}
%%
override gv_view_area_map_location
static PyObject *
_wrap_gv_view_area_map_location(PyGObject *self, PyObject *args)
{
    gvgeocoord  x, y;

    if (!PyArg_ParseTuple(args, "(" CC "):GvViewArea.map_location", &x, &y))
        return NULL;

    gv_view_area_map_location( GV_VIEW_AREA(self->obj), x, y, &x, &y );

    return Py_BuildValue("(" CC ")", x, y );
}
%%
override gv_view_area_get_pointer noargs
static PyObject *
_wrap_gv_view_area_get_pointer(PyGObject *self)
{
    GvViewArea *view;
    gvgeocoord  x, y;

    view = GV_VIEW_AREA(self->obj);

    gv_view_area_map_pointer(view, view->state.mpos_x,
                            view->state.mpos_y, &x, &y );

    return Py_BuildValue("(" CC ")", x, y );
}
%%
override gv_view_area_map_pointer
static PyObject *
_wrap_gv_view_area_map_pointer(PyGObject *self, PyObject *args)
{
    gvgeocoord  x, y;

    if (!PyArg_ParseTuple(args, "(" CC "):GvViewArea.map_pointer", &x, &y))
        return NULL;

    gv_view_area_map_pointer(  GV_VIEW_AREA(self->obj), x, y, &x, &y );

    return Py_BuildValue("(" CC ")", x, y );
}
%%
override gv_view_area_get_extents noargs
static PyObject *
_wrap_gv_view_area_get_extents(PyGObject *self)
{
    gvgeocoord xmin, ymin, xmax, ymax;

    gv_view_area_get_extents( GV_VIEW_AREA(self->obj), &xmin, &ymin, &xmax, &ymax );

    return Py_BuildValue("(" CCCC ")", xmin, ymin, xmax, ymax );
}
%%
override gv_view_area_get_volume noargs
static PyObject *
_wrap_gv_view_area_get_volume(PyGObject *self)
{
    double  volume[6];

    gv_view_area_get_volume( GV_VIEW_AREA(self->obj), volume );

    return Py_BuildValue("(" CCCCCC ")",
                         volume[0], volume[1],
                         volume[2], volume[3],
                         volume[4], volume[5] );
}

%%
override gv_view_area_inverse_map_pointer
static PyObject *
_wrap_gv_view_area_inverse_map_pointer(PyGObject *self, PyObject *args)
{
    gvgeocoord x, y;

    if (!PyArg_ParseTuple(args, "(" CC "):GvViewArea.inverse_map_pointer", &x, &y))
        return NULL;

    gv_view_area_inverse_map_pointer( GV_VIEW_AREA(self->obj), x, y, &x, &y );

    return Py_BuildValue("(" CC ")", x, y );
}
%%
override gv_view_area_get_fontnames noargs
static PyObject *
_wrap_gv_view_area_get_fontnames(PyGObject *self)
{
    GPtrArray *g_list;
    PyObject  *py_list;
    int       i;

    g_list = gv_view_area_get_fontnames( GV_VIEW_AREA(self->obj) );

    py_list = PyList_New(0);
    for( i = 0; i < g_list->len; i++ )
    {
        const char  *item = (const char *) g_ptr_array_index(g_list,i);
        PyObject    *py_item;

        py_item = Py_BuildValue( "s", item );
        PyList_Append( py_list, py_item );
        Py_DECREF( py_item );
    }

    g_ptr_array_free( g_list, FALSE );

    return py_list;
}
%%
override gv_view_area_set_background_color
static PyObject *
_wrap_gv_view_area_set_background_color(PyGObject *self, PyObject *args)
{
    GvColor color;

    if (!PyArg_ParseTuple(args, "(ffff):GvViewArea.set_background_color",
                            &color[0], &color[1], &color[2], &color[3]))
        return NULL;

    gv_view_area_set_background_color(GV_VIEW_AREA(self->obj), color);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_get_background_color noargs
static PyObject *
_wrap_gv_view_area_get_background_color(PyGObject *self)
{
    GvColor color;

    gv_view_area_get_background_color(GV_VIEW_AREA(self->obj), color);

    return Py_BuildValue("(ffff)", color[0], color[1], color[2], color[3] );
}
%%
override gv_view_area_set_3d_view
static PyObject *
_wrap_gv_view_area_set_3d_view(PyGObject *self, PyObject *args)
{
    vec3_t     eye_pos, eye_dir;

    if (!PyArg_ParseTuple(args,  "(" CCC ")(" CCC "):GvViewArea.set_3d_view",
                          eye_pos+0, eye_pos+1, eye_pos+2,
                          eye_dir+0, eye_dir+1, eye_dir+2))
        return NULL;

    gv_view_area_set_3d_view( GV_VIEW_AREA(self->obj), eye_pos, eye_dir );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_set_3d_view_look_at
static PyObject *
_wrap_gv_view_area_set_3d_view_look_at(PyGObject *self, PyObject *args)
{
    vec3_t     eye_pos;
    gvgeocoord eye_look_at[2];

    if (!PyArg_ParseTuple(args, "(" CCC ")(" CC "):GvViewArea.set_3d_view_look_at",
                          eye_pos+0, eye_pos+1, eye_pos+2,
                          eye_look_at+0, eye_look_at+1))
        return NULL;

    gv_view_area_set_3d_view_look_at( GV_VIEW_AREA(self->obj), eye_pos, eye_look_at );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define GvViewArea.get_eye_pos noargs
static PyObject *
_wrap_gv_view_area_get_eye_pos(PyGObject *self)
{
    GvViewArea *view = GV_VIEW_AREA(self->obj);

    return Py_BuildValue( "(" CCC ")",
                          view->state.eye_pos[0],
                          view->state.eye_pos[1],
                          view->state.eye_pos[2] );
}
%%
define GvViewArea.get_eye_dir noargs
static PyObject *
_wrap_gv_view_area_get_eye_dir(PyGObject *self)
{
    GvViewArea *view = GV_VIEW_AREA(self->obj);

    return Py_BuildValue( "(" CCC ")",
                          view->state.eye_dir[0],
                          view->state.eye_dir[1],
                          view->state.eye_dir[2] );
}
%%
override gv_view_area_get_look_at_pos noargs
static PyObject *
_wrap_gv_view_area_get_look_at_pos(PyGObject *self)
{
    gvgeocoord  x, y;

    if (!gv_view_area_get_look_at_pos( GV_VIEW_AREA(self->obj), &x, &y))
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return Py_BuildValue("(" CC ")", x, y);
}
%%
override gv_view_area_format_point_query
static PyObject *
_wrap_gv_view_area_format_point_query(PyGObject *self, PyObject *args)
{
    gdouble x, y;
    char *text;
    GvManager *manager;

    if (!PyArg_ParseTuple(args, "dd:GvViewArea.format_point_query", &x, &y))
        return NULL;

    manager = gv_get_manager();

    text = (char *) gv_view_area_format_point_query(GV_VIEW_AREA(self->obj),
                                                    &(manager->preferences), x, y);

    return Py_BuildValue("s", text);
}
%%
override gv_view_area_create_thumbnail
static PyObject *
_wrap_gv_view_area_create_thumbnail(PyGObject *self, PyObject *args)
{
#ifndef PENDING_GTK2
    PyErr_SetString(PyExc_RuntimeError, "not supported on this platform");
    return NULL;
#else

    GvViewArea *view;
    PyGObject *py_layer;
    PyObject *ret;
    GvLayer *layer;
    GdkPixmap *pixmap;
    int width, height;

    if (!PyArg_ParseTuple(args, "O!ii:gv_view_area_create_thumbnail",
              &PyGvLayer_Type, &py_layer, &width, &height)) {
    return NULL;
    }

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
    PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
    return NULL;
    }
    layer = GV_LAYER(py_layer->obj);
    if (!GV_IS_LAYER(layer)) {
    PyErr_SetString(PyExc_TypeError, "argument must be a GvLayer");
    return NULL;
    }

    pixmap = gv_view_area_create_thumbnail(view, layer, width, height);
    if (!pixmap) {
        PyErr_SetString(PyExc_RuntimeError, "could not create pixmap");
        return NULL;
    }
    ret = PyGdkWindow_New(pixmap);
    gdk_pixmap_unref(pixmap);
    return ret;
#endif
}
%%
define gv_have_ogr_support noargs
static PyObject *
_wrap_gv_have_ogr_support(PyObject *self)
{
    return PyInt_FromLong(gv_have_ogr_support());
}
%%
define GvShapes.num_shapes noargs
static PyObject *
_wrap_gv_shapes_num_shapes(PyGObject *self)
{
    PyInt_FromLong(gv_shapes_num_shapes(GV_SHAPES(self->obj)));
}
%%
%%
override gv_build_skirt kwargs
static PyObject *
_wrap_gv_build_skirt(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "base_height", NULL };
    GvRasterLayer *rlayer;
    double base_z = 0.0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|d:GvRasterLayer.build_skirt",
                                    kwlist, &base_z))
        return NULL;

    rlayer = GV_RASTER_LAYER(self->obj);

    return pygobject_new((GObject *)gv_build_skirt(rlayer, base_z));
}
%%
override gv_symbol_manager_get_names noargs
static PyObject *
_wrap_gv_symbol_manager_get_names(PyGObject *self)
{
    PyObject *py_name_list;
    GvSymbolManager *manager;
    char **name_list;
    int i, count;

    manager = GV_SYMBOL_MANAGER(self->obj);
    name_list = gv_symbol_manager_get_names(manager);
    
    count = CSLCount( name_list );
    py_name_list = PyList_New( count );
    for( i = 0; i < count; i++ )
        PyList_SetItem( py_name_list, i, Py_BuildValue( "s", name_list[i] ) );
    
    g_free( name_list );

    return py_name_list;
}
%%
override gv_symbol_manager_inject_vector_symbol
static PyObject *
_wrap_gv_symbol_manager_inject_vector_symbol(PyGObject *self, PyObject *args)
{
    PyObject *py_shape;
    GvSymbolManager *manager;
    char     *symbol_name = NULL;

    if (!PyArg_ParseTuple(args, "sO!:GvSymbolManager.inject_vector_symbol",
                          &symbol_name, &PyGvShape_Type, &py_shape))
        return NULL;

    manager = GV_SYMBOL_MANAGER(self->obj);

    gv_symbol_manager_inject_vector_symbol(manager, symbol_name, GV_SHAPE(py_shape));

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_symbol_manager_inject_raster_symbol
static PyObject *
_wrap_gv_symbol_manager_inject_raster_symbol(PyGObject *self, PyObject *args)
{
    GvSymbolManager *manager;
    char     *rgba_string = NULL;
    char     *symbol_name = NULL;
    int      width, height, rgba_len;

    if (!PyArg_ParseTuple(args, "siiz#:GvSymbolManager.inject_raster_symbol",
                          &symbol_name, &width, &height, &rgba_string, &rgba_len ))
        return NULL;

    manager = GV_SYMBOL_MANAGER(self->obj);

    if( width*height*4 > rgba_len )
    {
        PyErr_SetString(PyExc_TypeError,
                        "rgba raster symbol buffer seems to be too small (width*height*4)\nin GvSymbolManager.inject_raster_symbol()." );
        return NULL;
    }

    gv_symbol_manager_inject_raster_symbol(manager, symbol_name,
                                            width, height, rgba_string );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_symbol_manager_get_symbol
static PyObject *
_wrap_gv_symbol_manager_get_symbol(PyGObject *self, PyObject *args)
{
    GvSymbolManager *manager;
    char     *symbol_name = NULL;
    GvSymbolObj *symbol;

    if (!PyArg_ParseTuple(args,"s:GvSymbolManager.get_symbol", &symbol_name ))
        return NULL;

    manager = GV_SYMBOL_MANAGER(self->obj);
    symbol = gv_symbol_manager_get_symbol(manager, symbol_name );

    if (symbol == NULL)
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    if (symbol->type == GV_SYMBOL_VECTOR)
    {
        PyObject *py_shape = pygv_shape_from_shape((GvShape*)symbol->buffer);
        return Py_BuildValue("(iO)", symbol->type, &PyGvShape_Type);
    }
    else
    {
        PyObject *py_rgba_buffer;
        PyObject *py_result;

        py_rgba_buffer =
            PyString_FromStringAndSize( symbol->buffer,
                                        symbol->width * symbol->height * 4 );

        py_result = Py_BuildValue("(iiiO)",
                                  symbol->type, symbol->width, symbol->height,
                                  py_rgba_buffer );
        Py_DECREF( py_rgba_buffer );

        return py_result;
    }
}
%%
override gv_symbol_manager_save_vector_symbol
static PyObject *
_wrap_gv_symbol_manager_save_vector_symbol(PyGObject *self, PyObject *args)
{
    char *symbol_name = NULL, *new_name = NULL;

    if (!PyArg_ParseTuple(args, "ss:GvSymbolManager.save_vector_symbol",
                          &symbol_name, &new_name))
        return NULL;

    if( symbol_name && new_name )
    {
        if (gv_symbol_manager_save_vector_symbol(GV_SYMBOL_MANAGER(self->obj),
                                                symbol_name, new_name))
        {
            Py_INCREF(Py_None);
            return Py_None;
        }
        else
        {
            PyErr_SetString(PyExc_TypeError,
                "error while saving new symbol in GvSymbolManager.save_vector_symbol()." );
            return NULL;
        }
    }

    return NULL;
}
%%
override gv_data_get_properties noargs
static PyObject *
_wrap_gv_data_get_properties(PyGObject *self)
{
    GvProperties *properties = NULL;
    PyObject *psDict = NULL;

    properties = gv_data_get_properties( GV_DATA(self->obj) );

    psDict = PyDict_New();
    if( properties != NULL )
    {
        int        i, count;

        count = gv_properties_count( properties );
        for( i = 0; i < count; i++ )
        {
            const char *value, *name;
            PyObject *py_name, *py_value;

            value = gv_properties_get_value_by_index(properties,i);
            name = gv_properties_get_name_by_index(properties,i);

            py_name = Py_BuildValue("s",name);
            py_value = Py_BuildValue("s",value);
            PyDict_SetItem( psDict, py_name, py_value );

            Py_DECREF(py_name);
            Py_DECREF(py_value);
        }
    }

    return psDict;
}
%%
define GvData.set_properties
static PyObject *
_wrap_gv_data_set_properties(PyGObject *self, PyObject *args)
{
    GvProperties *properties = NULL;
    PyObject *psDict = NULL;
    PyObject    *pyKey = NULL, *pyValue = NULL;
    int ii;

    if (!PyArg_ParseTuple(args, "O!:GvData.set_properties", &PyDict_Type, &psDict))
        return NULL;

    properties = gv_data_get_properties( GV_DATA(self->obj) );
    gv_properties_clear( properties );

    ii = 0;
    while( PyDict_Next( psDict, &ii, &pyKey, &pyValue ) )
    {
        char *key = NULL, *value = NULL;

        if( !PyArg_Parse( pyKey, "s", &key )
            || !PyArg_Parse( pyValue, "s", &value ))
            continue;

        gv_properties_set( properties, key, value );

        pyKey = pyValue = NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_data_changing kwargs
static PyObject *
_wrap_gv_data_changing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x_off", "y_off", "width", "height", NULL };
    GvRaster *raster;
    int      x_off=0, y_off=0, width=0, height=0;
    GvRasterChangeInfo change_info;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iiii:GvData.changing",
                                    kwlist, &x_off, &y_off, &width, &height ))
        return NULL;

    if (GV_IS_RASTER(self->obj)) {
        raster = GV_RASTER(self->obj);

        if( height > 0 ) {
            change_info.change_type = GV_CHANGE_REPLACE;
            change_info.x_off = x_off;
            change_info.y_off = y_off;
            change_info.width = width;
            change_info.height = height;

            gv_data_changing( GV_DATA(raster), &change_info );
        }
        else
            gv_data_changing( GV_DATA(raster), NULL );
    }
    else {
        PyErr_SetString(PyExc_TypeError, "argument must be a handled GvData type");
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_data_changed kwargs
static PyObject *
_wrap_gv_data_changed(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x_off", "y_off", "width", "height", NULL };
    GvRaster *raster;
    GvData *data;
    int      x_off=0, y_off=0, width=0, height=0;
    GvRasterChangeInfo change_info;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iiii:GvData.changed",
                                    kwlist, &x_off, &y_off, &width, &height ))
        return NULL;

    if (GV_IS_RASTER(self->obj)) {
        raster = GV_RASTER(self->obj);

        if( height > 0 ) {
            change_info.change_type = GV_CHANGE_REPLACE;
            change_info.x_off = x_off;
            change_info.y_off = y_off;
            change_info.width = width;
            change_info.height = height;
    
            gv_data_changed( GV_DATA(raster), &change_info );
        }
        else
            gv_data_changed( GV_DATA(raster), NULL );
    }
    else {
        data = GV_DATA(self->obj);
        if (!GV_IS_DATA(data)) {
            PyErr_SetString(PyExc_TypeError, "data argument must be a GvData object");
            return NULL;
        }
        gv_data_changed( GV_DATA(data), NULL );
    }

    Py_INCREF(Py_None);
    return Py_None;
}
/* 
 * %%
 * define GvData.destroy noargs
 * static void
 * _wrap_gv_data_destroy(PyGObject *self)
 * {
 *     gv_data_destroy(GV_DATA(pygobject_get(self)));
 * }
 * %%
 * override-slot GvData.tp_dealloc
 * static void
 * _wrap_gv_data_tp_dealloc(PyGObject *self)
 * {
 *     if (self->obj) {
 *         g_object_unref(self->obj);
 *         self->obj = NULL;
 *     }
 * 
 *     PyObject_Del((PyObject*) self);
 * }
 */

%%
override gv_layer_extents noargs
static PyObject *
_wrap_gv_layer_extents(PyGObject *self)
{
    GvRect rect;

    gv_layer_extents(GV_LAYER(self->obj), &rect);

    return Py_BuildValue( "(" CCCC ")", rect.x, rect.y, rect.width, rect.height);
}
%%
override gv_layer_display_change noargs
static PyObject *
_wrap_gv_layer_display_change(PyGObject *self)
{
    gv_layer_display_change(GV_LAYER(self->obj), NULL);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_roi_tool_get_rect noargs
static PyObject *
_wrap_gv_roi_tool_get_rect(PyGObject *self)
{
    GvRect rect;

    if (!gv_roi_tool_get_rect(GV_ROI_TOOL(self->obj), &rect)) {
        PyErr_SetString(PyExc_RuntimeError, "no ROI marked");
        return NULL;
    }

    return Py_BuildValue("(" CCCC ")", rect.x, rect.y, rect.width, rect.height);
}
%%
override gv_roi_tool_new_rect
static PyObject *
_wrap_gv_roi_tool_new_rect(PyGObject *self, PyObject *args)
{
    GvRect rect;

    if (!PyArg_ParseTuple(args, "(" CCCC "):GvRoiTool.new_rect",
                            &rect.x, &rect.y, &rect.width, &rect.height))
        return NULL;

    if (!gv_roi_tool_new_rect(GV_ROI_TOOL(self->obj), &rect)){
        PyErr_SetString(PyExc_RuntimeError, "invalid ROI specified");
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_poi_tool_get_point noargs
static PyObject *
_wrap_gv_poi_tool_get_point(PyGObject *self)
{
    GvVertex point;

    if (!gv_poi_tool_get_point(GV_POI_TOOL(self->obj), &point)) {
        PyErr_SetString(PyExc_RuntimeError, "no POI marked");
        return NULL;
    }

    return Py_BuildValue("(" CC ")", point.x, point.y);
}
%%
override gv_poi_tool_new_point
static PyObject *
_wrap_gv_poi_tool_new_point(PyGObject *self, PyObject *args)
{
    GvVertex point;

    if (!PyArg_ParseTuple(args, "(" CC "):GvPoiTool.new_point",
                            &point.x, &point.y))
        return NULL;

    if (!gv_poi_tool_new_point(GV_POI_TOOL(self->obj), &point)) {
        PyErr_SetString(PyExc_RuntimeError, "invalid POI specified");
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_tool_set_boundary
static PyObject *
_wrap_gv_tool_set_boundary(PyGObject *self, PyObject *args)
{
    GvRect rect;

    if (!PyArg_ParseTuple(args, "(" CCCC "):gv_tool_set_boundary",
                          &rect.x, &rect.y, &rect.width, &rect.height))
        return NULL;

    if (!gv_tool_set_boundary(GV_TOOL(self->obj), &rect)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "invalid ROI constraining region specified, width or height <= 0.0");
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_shapes_new kwargs
static int
_wrap_gv_shapes_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { "shapefilename", NULL };
    char *filename;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:_gv.Shapes.__init__",
                                     kwlist, &filename))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create _gv.Shapes object");
        return -1;
    }
    if (filename != NULL)
        gv_shapes_read_from_file(filename, GV_SHAPES (self->obj));

    return 0;
}
%%
new-constructor GV_TYPE_SHAPES
%%
override-slot GvShapes.tp_as_sequence
static int
_wrap_gv_shapes_sq_length(PyGObject *self)
{
    return gv_shapes_num_shapes(GV_SHAPES(self->obj));
}

static PyObject *
_wrap_gv_shapes_sq_item(PyGObject *self, int shp_index)
{
    if (shp_index < 0 || shp_index >= gv_shapes_num_shapes(GV_SHAPES(self->obj))) {
        PyErr_SetString(PyExc_IndexError, "shape index out of range");
        return NULL;
    }

    GvShape *shape = gv_shapes_get_shape(GV_SHAPES(self->obj), shp_index);
    
    if (shape)
        return pygv_shape_from_shape(shape);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}

static int
_wrap_gv_shapes_sq_ass_item(PyGObject *self, int shp_index, PyObject *shape)
{
    GvShape **shape_list = NULL;
    int      *shape_id = NULL;

    if (shp_index < 0 || shp_index >= gv_shapes_num_shapes(GV_SHAPES(self->obj))) {
        PyErr_SetString(PyExc_IndexError, "shape index out of range");
        return -1;
    }

    if (! PyObject_TypeCheck(shape, &PyGvShape_Type)) {
        PyErr_SetString(PyExc_TypeError, "arg 2 not a GvShape object");
        return -1;
    }

    shape_id = g_new(int, 1);
    shape_list = g_new(GvShape*, 1);
    shape_list[0] = GV_SHAPE(shape);

    gv_shapes_replace_shapes(GV_SHAPES(self->obj), 1, shape_id, shape_list, FALSE);
    
    g_free(shape_id);
    g_free(shape_list);

    return 0;
}

static PySequenceMethods _wrap_gv_shapes_tp_as_sequence = {
    (inquiry)_wrap_gv_shapes_sq_length,
    0,
    0,
    (intargfunc)_wrap_gv_shapes_sq_item,
    0,
    (intobjargproc)_wrap_gv_shapes_sq_ass_item,
    0,
    0,
//~         binaryfunc sq_concat;
//~         intargfunc sq_repeat;
//~         intintargfunc sq_slice;
//~         intintobjargproc sq_ass_slice;
//~         objobjproc sq_contains;
//~         /* Added in release 2.0 */
//~         binaryfunc sq_inplace_concat;
//~         intargfunc sq_inplace_repeat;
};
%%
define GvShapes.get_fid
static PyObject *
_wrap_gv_shapes_get_fid(PyGObject *self, PyObject *args)
{
    GvProperties *properties = NULL;
    char *field = NULL;
    int field_index, fid = 0;

    if (!PyArg_ParseTuple(args, "s:GvShapes.get_fid", &field))
        return NULL;

    properties = gv_data_get_properties(GV_DATA(self->obj));
    if (properties == NULL) {
        PyErr_SetString(PyExc_ValueError, "no properties in GvShapes.get_fid()");
        return NULL;
    }

    for (field_index = 1; TRUE; field_index++)
    {
        char name[64];
        const char *prop_value;

        sprintf(name, "_field_name_%d", field_index);
        prop_value = gv_properties_get(properties, name);
        if (prop_value == NULL)
            break;
        if ( g_strcasecmp(prop_value, field) == 0 ) {
            fid = field_index;
            break;
        }
    }

    if (fid != 0)
        return Py_BuildValue("i", fid);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gv_shapes_to_dbf
static PyObject *
_wrap_gv_shapes_to_dbf(PyGObject *self, PyObject *args) {
    char *filename;

    if (!PyArg_ParseTuple(args, "s:GvShapes.to_dbf", &filename))
        return NULL;

    return PyInt_FromLong(gv_shapes_to_dbf(filename, GV_DATA(self->obj)));
}
%%
override gv_shapes_from_ogr_layer
static PyObject *
_wrap_gv_shapes_from_ogr_layer(PyObject *self, PyObject *args)
{
    GvData    *data = NULL;
    char      *ogrlayer_in = NULL;
    void      *hLayer;
    PyObject *py_ret = NULL;

    if (!PyArg_ParseTuple(args, "s:GvShapes.from_ogr_layer",
                          &ogrlayer_in) )
        return NULL;

    hLayer = SWIG_SimpleGetPtr(ogrlayer_in, "OGRLayerH" );
    if( hLayer == NULL )
    {
        PyErr_SetString(PyExc_IOError,
                        "Unable to extract OGRLayerH handle in GvShapes.from_ogr_layer()");
        return NULL;
    }

    data = gv_shapes_from_ogr_layer( hLayer );
    if( data == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return pygobject_new( G_OBJECT(data) );
}
%%
define GvShapes.get_shape
static PyObject *
_wrap_gv_shapes_get_shape(PyGObject *self, PyObject* args)
{
    int shp_index = -1;
    GvShape* shape = NULL;
    
    if (!PyArg_ParseTuple(args, "i:GvShapes.get_shape", &shp_index))
        return NULL;

    if (shp_index < 0 || shp_index >= gv_shapes_num_shapes(GV_SHAPES(self->obj))) {
        PyErr_SetString(PyExc_IndexError, "shape index out of range");
        return NULL;
    }

    shape = gv_shapes_get_shape(GV_SHAPES(self->obj), shp_index);
    if (shape)
        return pygv_shape_from_shape(shape);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
define GvShapes.append
static PyObject *
_wrap_gv_shapes_append(PyGObject *self, PyObject *args)
{
    PyObject *py_shape;
    int       shp_index = -1;

    if (!PyArg_ParseTuple(args, "O!:GvShapes.append", &PyGvShape_Type, &py_shape))
        return NULL;

    if (GV_SHAPE(py_shape))
        shp_index = gv_shapes_add_shape(GV_SHAPES(self->obj), GV_SHAPE(py_shape));

    return Py_BuildValue("i", shp_index);
}
%%
define GvShapes.append_last
static PyObject *
_wrap_gv_shapes_append_last(PyGObject *self, PyObject *args)
{
    PyObject *py_shape;
    int       shp_index = -1;

    if (!PyArg_ParseTuple(args, "O!:GvShapes.append_last", &PyGvShape_Type, &py_shape))
        return NULL;

    if (GV_SHAPE(py_shape))
        shp_index = gv_shapes_add_shape_last(GV_SHAPES(self->obj), GV_SHAPE(py_shape));

    return Py_BuildValue("i", shp_index);
}
%%
override gv_shapes_delete_shapes
static PyObject *
_wrap_gv_shapes_delete_shapes(PyGObject *self, PyObject *args)
{
    int       shape_count, ii;
    PyObject *pylist = NULL;
    int      *shape_ids = NULL;

    if (!PyArg_ParseTuple(args, "O!:GvShapes.delete_shapes", &PyList_Type, &pylist))
        return NULL;

    shape_count = PyList_Size(pylist);
    shape_ids = g_new(int, shape_count);

    for( ii = 0; ii < shape_count; ii++ )
    {
        if( !PyArg_Parse( PyList_GET_ITEM(pylist,ii), "i", shape_ids + ii ) )
        {
            PyErr_SetString(PyExc_ValueError,
                           "expecting ints in GvShapes.delete_shapes argument");
            return NULL;
        }
    }

    gv_shapes_delete_shapes(GV_SHAPES(self->obj), shape_count, shape_ids);

    g_free(shape_ids);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_shapes_replace_shapes
static PyObject *
_wrap_gv_shapes_replace_shapes(PyGObject *self, PyObject *args)
{
    int       shape_count, i;
    PyObject *pyindex_list = NULL, *pyshape_list = NULL;
    GvShape **shape_list = NULL;
    int      *shape_ids = NULL;
    int      copy_flag = FALSE;

    if (!PyArg_ParseTuple(args, "O!O!|d:GvShapes.replace_shapes",
                          &PyList_Type, &pyindex_list,
                          &PyList_Type, &pyshape_list,
                          &copy_flag ) )
        return NULL;

    if( PyList_Size(pyindex_list) != PyList_Size(pyshape_list) )
    {
        PyErr_SetString(PyExc_RuntimeError,
              "Size of index & shape lists differ in GvShapes.replace_shapes().");
        return NULL;
    }

    shape_count = PyList_Size(pyindex_list);
    shape_ids = g_new(int,shape_count);
    shape_list = g_new(GvShape*,shape_count);

    for( i = 0; i < shape_count; i++ )
    {
        PyGvShape *py_shape = NULL;

        if( !PyArg_Parse( PyList_GET_ITEM(pyindex_list,i), "i", shape_ids+i ))
        {
            PyErr_SetString(PyExc_ValueError,
                           "expecting ints in GvShapes.replace_shapes argument");
            return NULL;
        }

        if( !PyArg_Parse( PyList_GET_ITEM(pyshape_list,i), "O", &py_shape ))
        {
            PyErr_SetString(PyExc_ValueError,
                        "expecting GvShape in GvShapes.replace_shapes argument");
            return NULL;
        }

        shape_list[i] = GV_SHAPE(py_shape);
    }

    gv_shapes_replace_shapes( GV_SHAPES(self->obj), shape_count,
                            shape_ids, shape_list, copy_flag );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_shapes_get_extents noargs
static PyObject *
_wrap_gv_shapes_get_extents(PyGObject *self)
{
    GvRect rect;

    gv_shapes_get_extents(GV_SHAPES(self->obj), &rect);

    return Py_BuildValue("(" CCCC ")", rect.x, rect.y, rect.width, rect.height);
}
%%
override gv_shapes_get_change_info
static PyObject *
_wrap_gv_shapes_get_change_info(PyObject *self, PyObject *args)
{
    GvShapeChangeInfo *change_info;
    PyObject *c_change_info;
    PyObject *id_list;
    int i;

    if (!PyArg_ParseTuple(args, "O:GvShapes.get_change_info", &c_change_info))
        return NULL;

    if (!pygobject_check(c_change_info, &PyGPointer_Type))
        return NULL;

    change_info = pyg_pointer_get(c_change_info, GvShapeChangeInfo);

    id_list = PyTuple_New(change_info->num_shapes);

    for(i=0; i<change_info->num_shapes; i++)
    {
        PyTuple_SetItem(id_list, i, PyInt_FromLong((long)change_info->shape_id[i]));
    }

    return Py_BuildValue( "(iiO)",
                         change_info->change_type,
                         change_info->num_shapes,
                         id_list );
}
%%
override gv_shape_layer_set_color
static PyObject *
_wrap_gv_shape_layer_set_color(PyGObject *self, PyObject *args)
{
    GvShapeLayer *layer;
    GvColor color;

    if (!PyArg_ParseTuple(args, "(ffff):gv_shape_layer_set_color",
              &color[0], &color[1], &color[2], &color[3])) {
    return NULL;
    }

    layer = GV_SHAPE_LAYER(self->obj);
    if (!GV_IS_SHAPE_LAYER(layer)) {
    PyErr_SetString(PyExc_TypeError, "argument must be a GvShapeLayer");
    return NULL;
    }

    gv_shape_layer_set_color(layer, color);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_shape_layer_get_selected
static PyObject *
_wrap_gv_shape_layer_get_selected(PyGObject *self, PyObject *args)
{
    GvShapeLayer *layer;
    PyObject  *list;
    GArray    *array;
    int       i;

    layer = GV_SHAPE_LAYER(self->obj);
    if (!GV_IS_SHAPE_LAYER(layer)) {
    PyErr_SetString(PyExc_TypeError, "argument must be a GvShapeLayer");
    return NULL;
    }

    array = g_array_new(FALSE,TRUE,sizeof(gint));
    gv_shape_layer_get_selected(layer, array);

    list = PyList_New(array->len);
    for( i = 0; i < array->len; i++ )
    {
        PyList_SetItem( list, i,
                        Py_BuildValue("i", g_array_index(array,gint,i)) );
    }

    g_array_free( array, TRUE );

    return list;
}
%%
override gv_shape_layer_pick_shape
static PyObject *
_wrap_gv_shape_layer_pick_shape( PyGObject *self, PyObject *args )
{
    PyGObject *py_view;
    GvShapeLayer *layer;
    GvViewArea *view;
    gint shape_id;
    float x, y;

    if (!PyArg_ParseTuple(args, "O!ff:gv_shape_layer_pick_shape",
                          &PyGvViewArea_Type, &py_view, &x, &y ))
    {
        return NULL;
    }

    layer = GV_SHAPE_LAYER(self->obj);
    if (!GV_IS_SHAPE_LAYER(layer)) {
    PyErr_SetString(PyExc_TypeError, "argument must be a GvShapeLayer");
    return NULL;
    }

    view = GV_VIEW_AREA(py_view->obj);
    if (!GV_IS_VIEW_AREA(view)) {
    PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
    return NULL;
    }

    if (gv_shape_layer_pick_shape(layer, view, x, y, &shape_id )) {
        return PyInt_FromLong( (long)shape_id );
    }
    else
    {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gv_shapes_layer_new kwargs
static int
_wrap_gv_shapes_layer_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "shapes", NULL };
    PyGObject *py_shapes;
    GvShapes *shapes_obj = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O!:_gv.ShapesLayer.__init__",
                                     kwlist, &PyGvShapes_Type, &py_shapes))
        return -1;

    /* ---- Get shapes or NULL ---- */
    if ((PyObject*)py_shapes == Py_None) {
        shapes_obj = NULL;
    }
    else if (pygobject_check(py_shapes, &PyGvShapes_Type)) {
        shapes_obj = GV_SHAPES (pygobject_get(py_shapes));
    }
    else {
        PyErr_SetString(PyExc_ValueError, "Incorrect shapes argument type");
        return -1;
    }

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GvShapesLayer object");
        return -1;
    }

    if (py_shapes->obj != NULL) {
        gv_shapes_layer_set_data(GV_SHAPES_LAYER(self->obj), shapes_obj);
    }
    return 0;
}
%%
new-constructor GV_TYPE_SHAPES_LAYER
%%
override gv_shapes_layer_get_symbol_manager kwargs
static PyObject *
_wrap_gv_shapes_layer_get_symbol_manager(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "ok_to_create", NULL };
    int ok_to_create = 0;
    GObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|i:GvShapesLayer.get_symbol_manager",
                                    kwlist, &ok_to_create))
        return NULL;
    
    ret = gv_shapes_layer_get_symbol_manager(GV_SHAPES_LAYER(self->obj), ok_to_create);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
%%
override gv_raster_new kwargs
static int
_wrap_gv_raster_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject * py_ret;
    char *filename = NULL, *dataset_string = NULL, *name;
    GDALDatasetH  dataset;
    static int gdal_initialized = 0;
    GvSampleMethod sm = GvSMAverage;
    int   rband = 1;
    static char *kwlist[] = {"filename", "sample", "real",
                             "dataset", NULL};
    GvRaster *raster;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ziiz:_gv.Raster.__init__", kwlist,
                                     &filename, &sm, &rband, &dataset_string))
        return -1;

    if( !gdal_initialized )
    {
        GDALAllRegister();
        gdal_initialized = 1;
    }

    if( dataset_string != NULL )
    {
        dataset = (GDALDatasetH)
            SWIG_SimpleGetPtr(dataset_string, "GDALDatasetH" );
        if (dataset == NULL)
        {
            PyErr_SetString(PyExc_IOError,
                 "Unable to extract GDALDatasetH handle in gv_raster_new()");
            return -1;
        }
    }
    else if( filename != NULL )
    {
        dataset = GDALOpen( filename, GA_ReadOnly );

        if (dataset == NULL)
        {
            PyErr_SetString(PyExc_IOError, "failed to open data file");
            return -1;
        }

        GDALDereferenceDataset( dataset );
    }
    else if( self->obj != NULL )
    {
        pygobject_constructv(self, 0, NULL);
        return 0;
    }
    else
    {
        PyErr_SetString(PyExc_IOError,
                        "_gv.Raster.__init__: either a filename, or dataset handle"
                        " is required.  Neither provided." );
        return -1;
    }

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create _gv.Raster object");
        return -1;
    }

    gv_raster_read(GV_RASTER(self->obj), dataset, rband, sm);
    /*pygobject_construct(self, "filename", filename,
                        "sample", sm,
                        "real", rband,
                        "dataset", dataset, NULL);*/

    return 0;
}
%%
new-constructor GV_TYPE_RASTER
%%
override gv_raster_autoscale kwargs
static PyObject *
_wrap_gv_raster_autoscale(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"alg", "alg_param", "assign", NULL};
    int alg = GvASAAutomatic, assign = 0, success;
    double alg_param = -1.0;
    GvRaster *raster;
    double   out_min, out_max;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|idi:GvRaster.autoscale", 
                                    kwlist, &alg, &alg_param, &assign))
        return NULL;

    raster = GV_RASTER(self->obj);

    if( assign == 0 )
    {
        success = gv_raster_autoscale(raster, alg, alg_param, 0, NULL,
                                      NULL, NULL);
        if( !success )
        {
            PyErr_SetString(PyExc_RuntimeError,
                            "GvRaster.autoscale() failed, failed to get samples?" );
            return NULL;
        }

        return Py_BuildValue("(dd)", raster->min, raster->max);
    }
    else
    {
        success = gv_raster_autoscale(raster, alg, alg_param,
                                      0, NULL,
                                      &out_min, &out_max);

        if( !success )
        {
            PyErr_SetString(PyExc_RuntimeError,
                            "GvRaster.autoscale() failed, failed to get samples?" );
            return NULL;
        }

        return Py_BuildValue("(dd)", out_min, out_max );
    }
}
%%
define GvRaster.get_band noargs
static PyObject *
_wrap_gv_raster_get_band(PyGObject *self)
{
    char swig_ptr[32];
    GDALRasterBandH band;

    band = GV_RASTER(self->obj)->gdal_band;

    if( band == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    SWIG_SimpleMakePtr( swig_ptr, band, "_GDALRasterBandH" );
    return Py_BuildValue("s", swig_ptr);
}
%%
override gv_raster_flush_cache kwargs
static PyObject *
_wrap_gv_raster_flush_cache(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x_off", "y_off", "width", "height", NULL };
    int x_off = 0, y_off = 0, width = 0, height = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|iiii:GvRaster.flush_cache",
                                    kwlist, &x_off, &y_off, &width, &height))
        return NULL;
    
    gv_raster_flush_cache(GV_RASTER(self->obj), x_off, y_off, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
define GvRaster.force_load noargs
static PyObject *
_wrap_gv_raster_force_load(PyGObject *self)
{
    int       i;
    GvRaster *raster = GV_RASTER(self->obj);

    for( i = 0; i < raster->max_tiles; i++ )
        gv_raster_tile_get( raster, i, 0 );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_raster_get_sample
static PyObject *
_wrap_gv_raster_get_sample(PyGObject *self, PyObject *args)
{
    GvRaster *raster;
    double x, y, real, imaginary;

    if (!PyArg_ParseTuple(args, "dd:GvRaster.get_sample", &x, &y))
        return NULL;

    raster = GV_RASTER(self->obj);

    if( !gv_raster_get_sample(raster, x, y, &real, &imaginary ) )
        return NULL;
    else if( GDALDataTypeIsComplex(raster->gdal_type) )
        return Py_BuildValue( "(ff)", real, imaginary );
    else
        return Py_BuildValue( "f", real );
}
%%
override gv_raster_georef_to_pixel
static PyObject *
_wrap_gv_raster_georef_to_pixel(PyGObject *self, PyObject *args)
{
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:GvRaster.georef_to_pixel", &x, &y ))
        return NULL;

    if( gv_raster_georef_to_pixel(GV_RASTER(self->obj), &x, &y, NULL) )
    {
        return Py_BuildValue( "(ff)", x, y );
    }
    else
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "georef_to_pixel transformation failed." );
        return NULL;
    }
}
%%
override gv_raster_pixel_to_georef
static PyObject *
_wrap_gv_raster_pixel_to_georef(PyGObject *self, PyObject *args)
{
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:GvRaster.pixel_to_georef", &x, &y))
        return NULL;

    if( gv_raster_pixel_to_georef(GV_RASTER(self->obj), &x, &y, NULL ) )
    {
        return Py_BuildValue("(ff)", x, y);
    }
    else
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "georef_to_pixel transformation failed." );
        return NULL;
    }
}
%%
define GvRaster.cursor_link_georef_to_pixel
static PyObject *
_wrap_gv_raster_cursor_link_georef_to_pixel(PyGObject *self, PyObject *args)
{
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:GvRaster.cursor_link_georef_to_pixel", &x, &y))
        return NULL;

    if( gv_raster_georef_to_pixelCL(GV_RASTER(self->obj), &x, &y, NULL) )
    {
        return Py_BuildValue( "(ff)", x, y );
    }
    else
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "georef_to_pixelCL transformation failed." );
        return NULL;
    }
}
%%
define GvRaster.cursor_link_pixel_to_georef
static PyObject *
_wrap_gv_raster_cursor_link_pixel_to_georef(PyGObject *self, PyObject *args)
{
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:GvRaster.cursor_link_pixel_to_georef", &x, &y))
        return NULL;

    if( gv_raster_pixel_to_georefCL(GV_RASTER(self->obj), &x, &y, NULL) )
    {
        return Py_BuildValue("(ff)", x, y);
    }
    else
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "georef_to_pixelCL transformation failed." );
        return NULL;
    }
}
%%
define GvRaster.get_change_info
static PyObject *
_wrap_gv_raster_get_change_info(PyGObject *self, PyObject *args)
{
    GvRasterChangeInfo *change_info;
    PyObject *c_change_info;

    if (!PyArg_ParseTuple(args, "O:GvRaster.get_change_info", &c_change_info))
        return NULL;

    if (!pygobject_check(c_change_info, &PyGPointer_Type))
        return NULL;

    change_info = pyg_pointer_get(c_change_info, GvRasterChangeInfo);

    return Py_BuildValue( "(iiiii)",
                          change_info->change_type,
                          change_info->x_off,
                          change_info->y_off,
                          change_info->width,
                          change_info->height
                         );
}
%%
override gv_raster_get_gcps noargs
static PyObject *
_wrap_gv_raster_get_gcps(PyGObject *self)
{
    GvRaster *raster;
    const GDAL_GCP * pasGCPList;
    PyObject *psList;
    int iGCP;

    raster = GV_RASTER(self->obj);
    pasGCPList = gv_raster_get_gcps(raster);

    psList = PyList_New(raster->gcp_count);
    for( iGCP = 0; pasGCPList != NULL && iGCP < raster->gcp_count; iGCP++)
    {
        PyObject *py_item;

        py_item = Py_BuildValue("(ssddddd)",
                                pasGCPList[iGCP].pszId,
                                pasGCPList[iGCP].pszInfo,
                                pasGCPList[iGCP].dfGCPPixel,
                                pasGCPList[iGCP].dfGCPLine,
                                pasGCPList[iGCP].dfGCPX,
                                pasGCPList[iGCP].dfGCPY,
                                pasGCPList[iGCP].dfGCPZ );
        PyList_SetItem(psList, iGCP, py_item );
    }

    return psList;
}
%%
override gv_raster_set_gcps
static PyObject *
_wrap_gv_raster_set_gcps(PyGObject *self, PyObject *args)
{
    GvRaster *raster;
    GDAL_GCP *pasGCPList;
    PyObject *psList;
    int iGCP, nGCPCount, success;

    if (!PyArg_ParseTuple(args,"O!:GvRaster.set_gcps", &PyList_Type, &psList))
        return NULL;

    raster = GV_RASTER(self->obj);

    nGCPCount = PyList_Size(psList);
    pasGCPList = (GDAL_GCP *) CPLCalloc(sizeof(GDAL_GCP),nGCPCount);
    GDALInitGCPs( nGCPCount, pasGCPList );

    for( iGCP = 0; iGCP < nGCPCount; iGCP++ )
    {
        char *pszId = NULL, *pszInfo = NULL;

        if( !PyArg_Parse( PyList_GET_ITEM(psList,iGCP), "(ssddddd)",
                      &pszId, &pszInfo,
                      &(pasGCPList[iGCP].dfGCPPixel),
                      &(pasGCPList[iGCP].dfGCPLine),
                      &(pasGCPList[iGCP].dfGCPX),
                      &(pasGCPList[iGCP].dfGCPY),
                      &(pasGCPList[iGCP].dfGCPZ) ) )
        {
            PyErr_SetString(PyExc_ValueError, "improper GCP tuple");
            return NULL;
        }

        CPLFree( pasGCPList[iGCP].pszId );
        pasGCPList[iGCP].pszId = CPLStrdup(pszId);
        CPLFree( pasGCPList[iGCP].pszInfo );
        pasGCPList[iGCP].pszInfo = CPLStrdup(pszInfo);
    }

    success = gv_raster_set_gcps( raster, nGCPCount, pasGCPList );

    GDALDeinitGCPs( nGCPCount, pasGCPList );
    CPLFree( pasGCPList );

    return Py_BuildValue("d", success);
}
%%
override gv_raster_get_gcpsCL noargs
static PyObject *
_wrap_gv_raster_get_gcpsCL(PyGObject *self)
{
    GvRaster *raster;
    const GDAL_GCP * pasGCPList;
    PyObject *psList;
    int iGCP;

    raster = GV_RASTER(self->obj);
    pasGCPList = gv_raster_get_gcpsCL( raster );

    psList = PyList_New(raster->gcp_countCL);
    for( iGCP = 0; pasGCPList != NULL && iGCP < raster->gcp_countCL; iGCP++)
    {
        PyObject *py_item;

        py_item = Py_BuildValue("(ssddddd)",
                                pasGCPList[iGCP].pszId,
                                pasGCPList[iGCP].pszInfo,
                                pasGCPList[iGCP].dfGCPPixel,
                                pasGCPList[iGCP].dfGCPLine,
                                pasGCPList[iGCP].dfGCPX,
                                pasGCPList[iGCP].dfGCPY,
                                pasGCPList[iGCP].dfGCPZ );
        PyList_SetItem(psList, iGCP, py_item );
    }

    return psList;
}
%%
override gv_raster_set_gcpsCL
static PyObject *
_wrap_gv_raster_set_gcpsCL(PyGObject *self, PyObject *args)
{
    GvRaster *raster;
    GDAL_GCP *pasGCPList;
    PyObject *psList;
    int iGCP, nGCPCount, success, poly_order;

    if (!PyArg_ParseTuple(args,"O!i:GvRaster.set_gcpsCL",
                            &PyList_Type, &psList,
                            &poly_order))
        return NULL;

    raster = GV_RASTER(self->obj);

    nGCPCount = PyList_Size(psList);
    pasGCPList = (GDAL_GCP *) CPLCalloc(sizeof(GDAL_GCP),nGCPCount);
    GDALInitGCPs( nGCPCount, pasGCPList );

    for( iGCP = 0; iGCP < nGCPCount; iGCP++ )
    {
        char *pszId = NULL, *pszInfo = NULL;

        if( !PyArg_Parse( PyList_GET_ITEM(psList,iGCP), "(ssddddd)",
                      &pszId, &pszInfo,
                      &(pasGCPList[iGCP].dfGCPPixel),
                      &(pasGCPList[iGCP].dfGCPLine),
                      &(pasGCPList[iGCP].dfGCPX),
                      &(pasGCPList[iGCP].dfGCPY),
                      &(pasGCPList[iGCP].dfGCPZ) ) )
        {
            PyErr_SetString(PyExc_ValueError, "improper GCP tuple");
            return NULL;
        }

        CPLFree( pasGCPList[iGCP].pszId );
        pasGCPList[iGCP].pszId = CPLStrdup(pszId);
        CPLFree( pasGCPList[iGCP].pszInfo );
        pasGCPList[iGCP].pszInfo = CPLStrdup(pszInfo);
    }

    success = gv_raster_set_gcpsCL( raster, nGCPCount, pasGCPList,poly_order);

    GDALDeinitGCPs( nGCPCount, pasGCPList );
    CPLFree( pasGCPList );

    return Py_BuildValue("d", success);
}

%%
define GvRaster.get_min noargs
static PyObject *
_wrap_gv_raster_get_min(PyGObject *self)
{
    return PyFloat_FromDouble(GV_RASTER(self->obj)->min);
}
%%
define GvRaster.get_max noargs
static PyObject *
_wrap_gv_raster_get_max(PyGObject *self)
{
    return PyFloat_FromDouble(GV_RASTER(self->obj)->max);
}
%%
override gv_raster_get_dataset noargs
static PyObject *
_wrap_gv_raster_get_dataset(PyGObject *self)
{
    char swig_ptr[32];
    GDALDatasetH dataset;

    dataset = GV_RASTER(self->obj)->dataset;
    if( dataset == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    SWIG_SimpleMakePtr( swig_ptr, dataset, "_GDALDatasetH" );
    return Py_BuildValue("s", swig_ptr);
}
%%
override gv_raster_rasterize_shapes
static PyObject *
_wrap_gv_raster_rasterize_shapes(PyGObject *self, PyObject *args)
{
    PyObject *py_shapelist;
    double   burn_value;
    int      shape_count, i, ret_value, fill_short = 1;
    GvShape  **shape_list;

    if (!PyArg_ParseTuple(args, "O!d|i:GvRaster.rasterize_shapes",
                            &PyList_Type, &py_shapelist,
                            &burn_value, &fill_short))
        return NULL;

    shape_count = PyList_Size(py_shapelist);
    shape_list = g_new(GvShape*,shape_count);
    for (i = 0; i < shape_count; i++)
    {
        PyGvShape *py_shape;

        if (!PyArg_Parse( PyList_GET_ITEM(py_shapelist, i), "O", &py_shape ))
        {
            g_free(shape_list);
            PyErr_SetString(PyExc_ValueError, "bad item in shapelist");
            return NULL;
        }

        shape_list[i] = GV_SHAPE(py_shape);
    }

    ret_value = gv_raster_rasterize_shapes(GV_RASTER(self->obj), shape_count,
                                            shape_list, burn_value, fill_short);

    return Py_BuildValue("i", ret_value);
}
%%
override gv_raster_layer_new
static int
_wrap_gv_raster_layer_new(PyGObject *self, PyObject *args)
{
    PyObject *py_properties = NULL;
    PyGObject *py_raster;
    GvRaster *raster;
    GvRasterLayer *layer;
    GvProperties properties = NULL;
    int      mode = GV_RLM_AUTO;
    double nodata_real=-1e8, nodata_imaginary=0.0;
    int nodata_active = FALSE;
    const char *interp_pref;

    if (!PyArg_ParseTuple(args, "O!iO!:_gv.RasterLayer.__init__", &PyGvRaster_Type,
                            &py_raster, &mode, &PyList_Type, &py_properties ))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create _gv.RasterLayer object");
        return -1;
    }

    raster = GV_RASTER(py_raster->obj);
    if (!GV_IS_RASTER(raster)) {
        PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
        return -1;
    }

    if( py_properties != NULL )
    {
        int     i;

        for( i = 0; i < PyList_Size(py_properties); i++ )
        {
            char *name, *value;
            PyObject *tuple = PyList_GET_ITEM(py_properties, i);

            if (!PyArg_ParseTuple(tuple, "ss", &name, &value))
            {
                PyErr_SetString(PyExc_ValueError, "properties format");
                return -1;
            }

            gv_properties_set( &properties, name, value );
        }
    }

    gv_raster_layer_read(GV_RASTER_LAYER(self->obj), mode, raster, properties);
    gv_properties_destroy( &properties );

    return 0;
}
%%
new-constructor GV_TYPE_RASTER_LAYER
%%
override gv_raster_layer_autoscale_view kwargs
static PyObject *
_wrap_gv_raster_layer_autoscale_view(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"alg", "alg_param", "isource", NULL};
    int alg = GvASAAutomatic, isrc = 0, success;
    double alg_param = -1.0;
    double   out_min, out_max;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|idi:GvRasterLayer.autoscale_view",
                                        kwlist, &alg, &alg_param, &isrc))
        return NULL;

    success = gv_raster_layer_autoscale_view(GV_RASTER_LAYER(self->obj), isrc,
                                            alg, alg_param, &out_min, &out_max );
    if( !success )
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "GvRasterLayer.autoscale_view() failed, failed to get samples?" );
        return NULL;
    }

    return Py_BuildValue("(dd)", out_min, out_max);
}
%%
define GvRasterLayer.get_mesh_lod noargs
static PyObject *
_wrap_gv_raster_layer_get_mesh_lod(PyGObject *self)
{
    return Py_BuildValue("i", GV_RASTER_LAYER(self->obj)->mesh->detail);
}
%%
override gv_raster_layer_histogram_view kwargs
static PyObject *
_wrap_gv_raster_layer_histogram_view(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"alg", "alg_param", "assign", NULL};
    PyObject *py_list;
    double   scale_min = 0.0, scale_max = 255.0;
    int      hist_size = 256, isrc = 0, hist_count, i;
    int      *histogram = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iddi:GvRasterLayer.histogram_view",
                                    kwlist, &isrc, &scale_min, &scale_max, &hist_size))
        return NULL;

    histogram = g_new(int, hist_size);

    hist_count = gv_raster_layer_histogram_view(GV_RASTER_LAYER(self->obj), isrc,
                                                scale_min, scale_max, TRUE,
                                                hist_size, histogram );
    if( hist_count == 0 )
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "GvRasterLayer.histogram_view() failed, failed to get samples?");
        return NULL;
    }

    py_list = PyList_New(0);
    for( i = 0; i < hist_size; i++ )
    {
        PyObject *py_value = Py_BuildValue("i", histogram[i]);
        PyList_Append(py_list, py_value);
        Py_DECREF( py_value );
    }
    g_free( histogram );

    return py_list;
}
%%
override gv_raster_layer_view_to_pixel
static PyObject *
_wrap_gv_raster_layer_view_to_pixel(PyGObject *self, PyObject *args)
{
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:GvRasterLayer.view_to_pixel", &x, &y))
        return NULL;

    if( gv_raster_layer_view_to_pixel(GV_RASTER_LAYER(self->obj), &x, &y, NULL) )
    {
        return Py_BuildValue("(ff)", x, y);
    }
    else
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "view_to_pixel transformation failed." );
        return NULL;
    }
}
%%
override gv_raster_layer_pixel_to_view
static PyObject *
_wrap_gv_raster_layer_pixel_to_view(PyGObject *self, PyObject *args)
{
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:GvRasterLayer.pixel_to_view", &x, &y))
        return NULL;

    if( gv_raster_layer_pixel_to_view(GV_RASTER_LAYER(self->obj), &x, &y, NULL) )
    {
        return Py_BuildValue("(ff)", x, y);
    }
    else
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "pixel_to_view transformation failed." );
        return NULL;
    }
}
%%
override gv_raster_layer_set_source
static PyObject *
_wrap_gv_raster_layer_set_source(PyGObject *self, PyObject *args)
{
    PyGObject *py_raster;
    GvRaster *raster = NULL;
    char *lut = NULL;
    int isource, const_value, ret, lut_len=0, nodata_active=FALSE;
    float min, max;
    PyObject *nodata = NULL;
    float nodata_real=-1e8, nodata_imaginary=0.0;

    if (!PyArg_ParseTuple( args, "iOffi|z#O:GvRasterLayer.set_source",
                           &isource, &py_raster, &min, &max,
                           &const_value, &lut, &lut_len, &nodata ))
        return NULL;

    if( py_raster->obj == NULL || (PyObject *)py_raster == Py_None )
        raster = NULL;
    else if (PyObject_TypeCheck(py_raster, &PyGvRaster_Type))
        raster = GV_RASTER(py_raster->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "2nd argument must be a GvRaster");
        return NULL;
    }

    if( nodata == NULL || nodata == Py_None )
    {
        nodata_real = 0.0;
        nodata_imaginary = 0.0;
        nodata_active = FALSE;
    }
    else if( PyTuple_Check(nodata) )
    {
        if( !PyArg_ParseTuple( nodata, "ff", &nodata_real, &nodata_imaginary) )
            return NULL;

        nodata_active = TRUE;
    }
    else
    {
        if( !PyArg_Parse( nodata, "f", &nodata_real ) )
            return NULL;

        nodata_imaginary = 0.0;
        nodata_active = TRUE;
    }

    ret = gv_raster_layer_set_source(GV_RASTER_LAYER(self->obj),
                                    isource, raster,
                                    min, max, const_value, lut,
                                    nodata_active,
                                    nodata_real, nodata_imaginary);

    return Py_BuildValue("i", ret);
}
%%
override gv_raster_layer_texture_mode_set
static PyObject *
_wrap_gv_raster_layer_texture_mode_set(PyGObject *self, PyObject *args)
{
    int texture_mode;
    GvColor color;

    if (!PyArg_ParseTuple(args, "i(ffff):GvRasterLayer.texture_mode_set",
                        &texture_mode, &color[0], &color[1], &color[2], &color[3]))
        return NULL;

    return PyInt_FromLong(gv_raster_layer_texture_mode_set(GV_RASTER_LAYER(self->obj),
                                                            texture_mode, color));
}
%%
override gv_raster_layer_texture_mode_get noargs
static PyObject *
_wrap_gv_raster_layer_texture_mode_get(PyGObject *self)
{
    int texture_mode;
    GvColor color;
    PyObject *py_color, *py_retval;

    if (gv_raster_layer_texture_mode_get(GV_RASTER_LAYER(self->obj), &texture_mode, &color))
    {
        Py_INCREF(Py_None);
        return Py_None;
    }
    else
    {
        py_color = Py_BuildValue( "(ffff)", color[0], color[1], color[2], color[3] );
        py_retval = Py_BuildValue( "(iO)", texture_mode, py_color );
        Py_DECREF( py_color );
        return py_retval;
    }
}
%%
override gv_raster_layer_alpha_get noargs
static PyObject *
_wrap_gv_raster_layer_alpha_get(PyGObject *self)
{
    float alpha_val;
    int alpha_mode;

    if (gv_raster_layer_alpha_get(GV_RASTER_LAYER(self->obj), &alpha_mode, &alpha_val))
    {
        Py_INCREF(Py_None);
        return Py_None;
    }
    else
    {
        return Py_BuildValue("(if)", alpha_mode, alpha_val);
    }
}
%%
override gv_raster_layer_blend_mode_get noargs
static PyObject *
_wrap_gv_raster_layer_blend_mode_get(PyGObject *self)
{
    int blend_mode;
    int sfactor;
    int dfactor;

    if (gv_raster_layer_blend_mode_get(GV_RASTER_LAYER(self->obj),
                                        &blend_mode, &sfactor, &dfactor))
    {
        Py_INCREF(Py_None);
        return Py_None;
    }
    else
    {
        return Py_BuildValue("(iii)", blend_mode, sfactor, dfactor);
    }
}
%%
override gv_raster_layer_lut_get kwargs
static PyObject *
_wrap_gv_raster_layer_lut_get(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"rgba_complex", NULL};
    PyObject *py_lut, *py_retval;
    char *lut;
    int width, height;
    int rgba_complex = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:GvRasterLayer.lut_get",
                                        kwlist, &rgba_complex))
        return NULL;

    lut = gv_raster_layer_lut_get(GV_RASTER_LAYER(self->obj),
                                    &width, &height, rgba_complex);
    if (lut == NULL)
    {
        Py_INCREF(Py_None);
        return Py_None;
    }
    else
    {
        py_lut = PyString_FromStringAndSize(lut, width * height * 4);
        if ( py_lut == NULL )
        {
            Py_INCREF(Py_None);
            return Py_None;
        }

        py_retval = Py_BuildValue("(Oii)", py_lut, width, height);
        Py_DECREF(py_lut);
        return py_retval;
    }
}
%%
override gv_raster_layer_nodata_get
static PyObject *
_wrap_gv_raster_layer_nodata_get(PyGObject *self, PyObject *args)
{
    int isource = 0;
    gint ret;
    double nodata_real, nodata_imaginary;

    if (!PyArg_ParseTuple( args, "|i:GvRasterLayer.nodata_get", &isource ))
        return NULL;

    GvRasterLayer *rlayer = GV_RASTER_LAYER(self->obj);

    ret = gv_raster_layer_nodata_get( rlayer, isource,
                                      &nodata_real, &nodata_imaginary );
    if( ret )
    {
        if( GDALDataTypeIsComplex(gv_raster_layer_type_get(rlayer, isource)) )
            return Py_BuildValue( "(ff)", nodata_real, nodata_imaginary );
        else
            return Py_BuildValue( "f", nodata_real );
    }
    else
    {
        Py_INCREF( Py_None );
        return Py_None;
    }
}
%%
define GvRasterLayer.get_nodata
static PyObject *
_wrap_gv_raster_layer_get_nodata(PyGObject *self, PyObject *args)
{
    int isource = 0;

    if (!PyArg_ParseTuple(args, "|i:GvRasterLayer.get_nodata", &isource))
        return NULL;

    GvRasterLayer *rlayer = GV_RASTER_LAYER(self->obj);

    if( rlayer != NULL && isource >= 0 && isource < rlayer->source_count )
    {
        GvRasterSource *source = rlayer->source_list + isource;

        if( source->nodata_active && source->data != NULL
            && source->data->gdal_type == GDT_CFloat32 )
            return Py_BuildValue( "(ff)", source->nodata_real,
                                  source->nodata_imaginary );
        else
            return Py_BuildValue( "f", source->nodata_real );
    }
    else
    {
        Py_INCREF( Py_None );
        return Py_None;
    }
}
%%
define GvRasterLayer.get_source_lut
static PyObject *
_wrap_gv_raster_layer_get_source_lut(PyGObject *self, PyObject *args)
{
    PyObject *py_lut;
    char *lut;
    int isource = 0;

    if (!PyArg_ParseTuple(args, "|i:GvRasterLayer.get_source_lut", &isource))
        return NULL;

    lut = gv_raster_layer_source_get_lut(GV_RASTER_LAYER(self->obj), isource);
    if( lut == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    if ( ( py_lut = PyString_FromStringAndSize( lut, 256 ) ) == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return py_lut;
}
%%
override gv_raster_layer_zoom_get noargs
static PyObject *
_wrap_gv_raster_layer_zoom_get(PyGObject *self)
{
    int mag, min;

    if( gv_raster_layer_zoom_get(GV_RASTER_LAYER(self->obj), &mag, &min) )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }
    else
    {
        return Py_BuildValue("(ii)", min, mag);
    }
}
%%
define GvRasterLayer.get_height
static PyObject *
_wrap_gv_raster_layer_get_height(PyGObject *self, PyObject *args)
{
    double x, y, result;
    int success;

    if (!PyArg_ParseTuple(args, "dd:GvRasterLayer.get_height", &x, &y))
        return NULL;

    result = gv_mesh_get_height(GV_RASTER_LAYER(self->obj)->mesh, x, y, &success);
    if (success)
        return Py_BuildValue("f", result);

    PyErr_SetString(PyExc_RuntimeError, "gv_mesh_get_height failed.");
    return NULL;
}
%%
override gv_raster_layer_type_get
static PyObject *
_wrap_gv_raster_layer_type_get(PyGObject *self, PyObject *args)
{
    int isource;

    if (!PyArg_ParseTuple(args, "i:GvRasterLayer.type_get", &isource))
        return NULL;

    return PyInt_FromLong((long)gv_raster_layer_type_get
              (GV_RASTER_LAYER(self->obj), isource));
}
%%
define GvRasterLayer.get_const_value
static PyObject *
_wrap_gv_raster_layer_get_const_value(PyGObject *self, PyObject *args)
{
    PyObject *py_lut;
    int isource = 0;

    if (!PyArg_ParseTuple(args, "|i:GvRasterLayer.get_const_value", &isource))
        return NULL;

    return PyInt_FromLong(gv_raster_layer_get_const_value
                            (GV_RASTER_LAYER(self->obj), isource));
}
%%
override gv_raster_layer_blend_mode_set kwargs
static PyObject *
_wrap_gv_raster_layer_blend_mode_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "blend_mode", "sfactor", "dfactor", NULL };
    int blend_mode, sfactor = 0, dfactor = 0;
    long ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i|ii:GvRasterLayer.blend_mode_set",
                                    kwlist, &blend_mode, &sfactor, &dfactor))
        return NULL;
    
    ret = gv_raster_layer_blend_mode_set(GV_RASTER_LAYER(self->obj), blend_mode, sfactor, dfactor);
    
    return PyInt_FromLong(ret);
}
%%
override gv_raster_layer_lut_put kwargs
static PyObject *
_wrap_gv_raster_layer_lut_put(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "lut", NULL };
    char *lut;
    int  lut_len, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z#:GvRasterLayer.lut_put",
                                    kwlist, &lut, &lut_len))
        return NULL;

    if( lut != NULL && lut_len != 1024 && lut_len != 1024 * 256 )
    {
        PyErr_SetString(PyExc_TypeError,
            "lut string must be 256x1x4 or 256x256x4 in GvRasterLayer.lut_put");
        return NULL;
    }

    height = lut_len / 1024;
    gv_raster_layer_lut_put(GV_RASTER_LAYER(self->obj), lut, height);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_raster_layer_lut_color_wheel_new_ev kwargs
static PyObject *
_wrap_gv_raster_layer_lut_color_wheel_new_ev(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "set_phase", "set_magnitude", NULL };
    int set_phase = 1, set_magnitude = 1, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ii:GvRasterLayer.lut_color_wheel_new_ev",
                                    kwlist, &set_phase, &set_magnitude))
        return NULL;
    
    ret = gv_raster_layer_lut_color_wheel_new_ev(GV_RASTER_LAYER(self->obj), set_phase, set_magnitude);
    
    return PyInt_FromLong(ret);
}
%%
override gv_raster_layer_add_height kwargs
static PyObject *
_wrap_gv_raster_layer_add_height(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "height_raster", "default_height", NULL };
    PyGObject *height_raster;
    double default_height = 0.0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|d:GvRasterLayer.add_height",
                                    kwlist, &PyGvRaster_Type, &height_raster, &default_height))
        return NULL;
    
    gv_raster_layer_add_height(GV_RASTER_LAYER(self->obj), GV_RASTER(height_raster->obj), default_height);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_raster_layer_clamp_height kwargs
static PyObject *
_wrap_gv_raster_layer_clamp_height(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "bclamp_min", "bclamp_max", "min_height", "max_height", NULL };
    int bclamp_min = 0, bclamp_max = 0;
    double min_height = -30000.0, max_height = 30000.0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|iidd:GvRasterLayer.clamp_height",
                        kwlist, &bclamp_min, &bclamp_max, &min_height, &max_height))
        return NULL;
    
    gv_raster_layer_clamp_height(GV_RASTER_LAYER(self->obj), bclamp_min, bclamp_max, min_height, max_height);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_manager_get_preferences noargs
static PyObject *
_wrap_gv_manager_get_preferences(PyGObject *self)
{
    GvProperties *properties = NULL;
    PyObject *psDict = NULL;

    properties = gv_manager_get_preferences(GV_MANAGER(self->obj));

    psDict = PyDict_New();
    if( properties != NULL )
    {
        int        i, count;

        count = gv_properties_count( properties );
        for( i = 0; i < count; i++ )
        {
            const char *value, *name;
            PyObject *py_name, *py_value;

            value = gv_properties_get_value_by_index(properties,i);
            name = gv_properties_get_name_by_index(properties,i);

            py_name = Py_BuildValue("s",name);
            py_value = Py_BuildValue("s",value);
            PyDict_SetItem( psDict, py_name, py_value );

            Py_DECREF(py_name);
            Py_DECREF(py_value);
        }
    }

    return psDict;
}
%%
override gv_manager_add_dataset
static PyObject *
_wrap_gv_manager_add_dataset(PyGObject *self, PyObject *args)
{
    char *dataset_string = NULL;
    char swig_ptr[32];
    GDALDatasetH dataset = NULL;

    if (!PyArg_ParseTuple(args, "s:GvManager.add_dataset", &dataset_string))
        return NULL;

    dataset = (GDALDatasetH) SWIG_SimpleGetPtr(dataset_string, "GDALDatasetH");
    if( dataset == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    dataset = gv_manager_add_dataset(GV_MANAGER(self->obj), dataset);
    SWIG_SimpleMakePtr(swig_ptr, dataset, "_GDALDatasetH");
    return Py_BuildValue("s", swig_ptr);
}
%%
override gv_manager_get_dataset
static PyObject *
_wrap_gv_manager_get_dataset(PyGObject *self, PyObject *args)
{
    char *filename = NULL;
    char swig_ptr[32];
    GDALDatasetH dataset = NULL;

    if (!PyArg_ParseTuple(args, "s:GvManager.get_dataset", &filename))
        return NULL;

    dataset = gv_manager_get_dataset(GV_MANAGER(self->obj), filename);

    if( dataset == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }
    else
    {
        SWIG_SimpleMakePtr(swig_ptr, dataset, "_GDALDatasetH");
        return Py_BuildValue("s", swig_ptr);
    }
}
%%
override gv_manager_get_dataset_raster
static PyObject *
_wrap_gv_manager_get_dataset_raster(PyGObject *self, PyObject *args)
{
    char *dataset_string = NULL;
    int band = 0;
    GDALDatasetH dataset = NULL;
    GvRaster *raster = NULL;

    if (!PyArg_ParseTuple(args, "si:GvManager.get_dataset_raster",
                          &dataset_string, &band))
        return NULL;

    dataset = (GDALDatasetH) SWIG_SimpleGetPtr(dataset_string, "GDALDatasetH");
    if( dataset == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    raster = gv_manager_get_dataset_raster(GV_MANAGER(self->obj), dataset, band);

    if( raster == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }
    else
    {
        PyObject *py_raster = pygobject_new( G_OBJECT(raster) );
        g_object_unref(raster);
        return py_raster;
    }
}
%%
override gv_manager_queue_task
static PyObject *
_wrap_gv_manager_queue_task(PyGObject *self, PyObject *args)
{
    int       priority;
    char      *task_name;
    PyTaskData *psProgressInfo;

    psProgressInfo = g_new(PyTaskData,1);
    psProgressInfo->psPyCallback = NULL;
    psProgressInfo->psPyCallbackData = Py_None;

    if (!PyArg_ParseTuple(args, "siO|O:GvManager.queue_task",
                          &task_name, &priority,
                          &(psProgressInfo->psPyCallback),
                          &(psProgressInfo->psPyCallbackData)) )
        return NULL;

    Py_XINCREF( psProgressInfo->psPyCallback );
    Py_XINCREF( psProgressInfo->psPyCallbackData );

    psProgressInfo->psThreadState = PyThreadState_Get();

    gv_manager_queue_task(GV_MANAGER(self->obj),
                            task_name, priority,
                            PyIdleTaskProxy,
                            psProgressInfo);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define gv_rgba_to_rgb
static PyObject *
_wrap_gv_rgba_to_rgb(PyObject *self, PyObject *args)
{
    PyObject *rgba_obj = NULL;
    PyObject *rgb_obj = NULL;
    const char *rgba;
    char       *rgb;
    int length, i;

    if (!PyArg_ParseTuple(args, "O!:gv_rgba_to_rgb", &PyString_Type, &rgba_obj))
        return NULL;

    length = PyString_Size( rgba_obj ) / 4;
    rgba = PyString_AS_STRING( rgba_obj );

    rgb = (char *) malloc(length*3);

    for( i = 0; i < length; i++ )
    {
        rgb[i*3  ] = rgba[i*4  ];
        rgb[i*3+1] = rgba[i*4+1];
        rgb[i*3+2] = rgba[i*4+2];
    }

    rgb_obj = PyString_FromStringAndSize( rgb, length * 3 );

    free( rgb );

    return rgb_obj;
}
%%
override WIDInterpolate
static PyObject *
_wrap_WIDInterpolate(PyObject *self, PyObject *args)
{
    PyObject *poPyPoints;
    PyProgressData sProgressInfo;
    char *pszSwigBand = NULL;
    int nPoints, i, nErr;
    double *padfXYVW;
    double fExponent;
    GDALRasterBandH hBand;

    sProgressInfo.psPyCallback = NULL;
    sProgressInfo.psPyCallbackData = NULL;

    if (!PyArg_ParseTuple(args, "O!s|dOO:WIDInterpolate",
                          &PyList_Type, &poPyPoints,
                          &pszSwigBand,
                          &fExponent,
                          &(sProgressInfo.psPyCallback),
                          &(sProgressInfo.psPyCallbackData) ) )
        return NULL;

    hBand = (GDALRasterBandH) SWIG_SimpleGetPtr(pszSwigBand, "_GDALRasterBandH");

    if( hBand == NULL )
    {
        PyErr_SetString( PyExc_ValueError,
                         "Couldn't parse GDALRasterBandH argument." );
        return NULL;
    }

    nPoints = PyList_Size(poPyPoints);
    padfXYVW = g_new(double,4*nPoints);
    for( i = 0; i < nPoints; i++ )
    {
        if( !PyArg_Parse( PyList_GET_ITEM(poPyPoints,i), "(dddd)",
                          padfXYVW + i + 0*nPoints,
                          padfXYVW + i + 1*nPoints,
                          padfXYVW + i + 2*nPoints,
                          padfXYVW + i + 3*nPoints ) )
        {
            g_free( padfXYVW );
            PyErr_SetString(PyExc_ValueError,
                            "bad point format (x,y,value,weight)");
            return NULL;
        }
    }

    nErr = WIDInterpolate( nPoints, padfXYVW, padfXYVW+nPoints,
                           padfXYVW+nPoints*2, padfXYVW+nPoints*3, hBand,
                           fExponent, PyProgressProxy, &sProgressInfo );

    g_free( padfXYVW );

    return Py_BuildValue( "i", nErr );
}
%%
override MyGDALOperator
static PyObject *
_wrap_MyGDALOperator(PyObject *self, PyObject *args)
{
    char *pszSwigDS1 = NULL;
    char *pszSwigDS2 = NULL;
    GDALDatasetH hDS1 = NULL, hDS2 = NULL;
    int  nErr = 1;

    if (!PyArg_ParseTuple(args, "ss:MyGDALOperator",
                          &pszSwigDS1, &pszSwigDS2 ) )
        return NULL;

    hDS1 = (GDALDatasetH) SWIG_SimpleGetPtr(pszSwigDS1, "_GDALDatasetH" );
    hDS2 = (GDALDatasetH) SWIG_SimpleGetPtr(pszSwigDS2, "_GDALDatasetH" );

    if( hDS1 != NULL && hDS2 != NULL )
    {
        /* do something with hDS1 and hDS2 */
        printf( "%s -> %s\n",
                GDALGetDescription( hDS1 ),
                GDALGetDescription( hDS2 ) );
        nErr = 0;
    }

    return Py_BuildValue( "i", nErr );
}
%%
override gv_launch_url
static PyObject *
_wrap_gv_launch_url(PyObject *self, PyObject *args)
{
    char *url = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_launch_url", &url))
        return NULL;

    return Py_BuildValue("i",gv_launch_url(url));
}
%%
override gv_short_path_name
static PyObject *
_wrap_gv_short_path_name(PyObject *self, PyObject *args)
{
    char *lpszLongPath = NULL;
    PyObject * result = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_short_path_name", &lpszLongPath))
        return NULL;

    result = Py_BuildValue("s",gv_short_path_name(lpszLongPath));

    //invalid path in lpszLongPath results in zero length string
    if (PyString_Size(result) == 0)
    {
        PyErr_Format(PyExc_OSError, "path (%s) does not exist.", lpszLongPath);
        return NULL;
    }

    return result;
}
%%
override gv_track_tool_new kwargs
static int
_wrap_gv_track_tool_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    PyGObject *label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:_gv.TrackTool.__init__",
                                    kwlist, &PyGtkObject_Type, &label))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GvTrackTool object");
        return -1;
    }

    GV_TRACK_TOOL(self->obj)->label = GTK_OBJECT(label->obj);
    return 0;
}
%%
new-constructor GV_TYPE_TRACK_TOOL
