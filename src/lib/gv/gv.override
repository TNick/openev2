/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#include <Python.h>               
#include "pygobject.h"
#include "gtkcolorwell.h"
#include "gvarealayer.h"
#include "gvareas.h"
#include "gvareatool.h"
#include "gvdata.h"
#include "gview.h"
#include "gvlayer.h"
#include "gvlinelayer.h"
#include "gvlinetool.h"
#include "gvmanager.h"
#include "gvmesh.h"
#include "gvnodetool.h"
#include "gvpointlayer.h"
#include "gvpoints.h"
#include "gvpointtool.h"
#include "gvpoitool.h"
#include "gvpolylines.h"
#include "gvpquerylayer.h"
#include "gvproperties.h"
#include "gvraster.h"
#include "gvrasterlayer.h"
#include "gvrecords.h"
#include "gvrecttool.h"
#include "gvroitool.h"
#include "gvrotatetool.h"
#include "gvselecttool.h"
#include "gvshapelayer.h"
#include "gvshapes.h"
#include "gvshapeslayer.h"
#include "gvsymbolmanager.h"
#include "gvtool.h"
#include "gvtoolbox.h"
#include "gvutils.h"
#include "gvtracktool.h"
#include "gvviewarea.h"
#include "gvviewlink.h"
#include "gvzoompantool.h"
#include "gv-enum-types.h"
#include "gv_override.h"
#include "invdistance.h"

%%
modulename _gv
%%
import gtk.DrawingArea as PyGtkDrawingArea_Type
import gtk.Button as PyGtkButton_Type
import gtk.Object as PyGtkObject_Type
import gtk.Adjustment as PyGtkAdjustment_Type
import gobject.GObject as PyGObject_Type
import gtk.Widget as PyGtkWidget_Type

%%
ignore-glob
  *_get_type                          
%%
override copy_obj kwargs
static PyObject *
_wrap_copy_obj(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "ttt", "sub", NULL };
    PyGObject *ttt, *sub;
    void *temp;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O!:copy_obj", kwlist, &PyGObject_Type, &ttt, &PyGObject_Type, &sub))
        return NULL;

    if (ttt->obj == NULL) {
      ttt->obj = sub->obj;
      /*sub->obj = NULL;*/
    }
    if (sub->obj == NULL) {
      sub->obj = ttt->obj;
      /*ttt->obj = NULL;*/
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_get_width
static PyObject *
_wrap_gv_view_area_get_width(PyGObject *self, PyObject *args)
{
    PyGObject *py_view;

    if (!PyArg_ParseTuple(args, "O!:gv_view_area_get_width", &PyGvViewArea_Type,
			  &py_view)) {
	return NULL;
    }

    return PyInt_FromLong(gv_view_area_get_width(GV_VIEW_AREA(py_view->obj)));
}
%%
override gv_view_area_get_height
static PyObject *_wrap_gv_view_area_get_height(PyGObject *self, PyObject *args) {
    PyGObject *py_view;

    if (!PyArg_ParseTuple(args, "O!:gv_view_area_get_height", &PyGvViewArea_Type,
			  &py_view)) {
	return NULL;
    }

    return PyInt_FromLong(gv_view_area_get_height(GV_VIEW_AREA(py_view->obj)));
}
%%
override gv_view_area_zoom
static PyObject *_wrap_gv_view_area_zoom(PyGObject *self, PyObject *args)
{
    double zoom;

    if (!PyArg_ParseTuple(args, "d:gv_view_area_zoom", &zoom))
        return NULL;
    gv_view_area_zoom(GV_VIEW_AREA(self->obj), zoom);
    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gv_view_area_get_zoom
static PyObject *_wrap_gv_view_area_get_zoom(PyGObject *self) {
    double ret;

    ret = gv_view_area_get_zoom(GV_VIEW_AREA(self->obj));
    return PyFloat_FromDouble(ret);
}

%%
override gv_view_area_rotate
static PyObject *_wrap_gv_view_area_rotate(PyGObject *self, PyObject *args) {
    double angle;

    if (!PyArg_ParseTuple(args, "d:gv_view_area_rotate", &angle))
        return NULL;
    gv_view_area_rotate(GV_VIEW_AREA(self->obj), angle);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_translate
static PyObject *_wrap_gv_view_area_translate(PyGObject *self, PyObject *args) {
    double dx, dy;

    if (!PyArg_ParseTuple(args, "dd:gv_view_area_translate", &dx, &dy))
        return NULL;
    gv_view_area_translate(GV_VIEW_AREA(self->obj), dx, dy);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_set_translation
static PyObject *_wrap_gv_view_area_set_translation(PyGObject *self, PyObject *args) {
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:gv_view_area_set_translation", &x, &y))
        return NULL;
    gv_view_area_set_translation(GV_VIEW_AREA(self->obj), x, y);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_fit_extents
static PyObject *_wrap_gv_view_area_fit_extents(PyGObject *self, PyObject *args) {
    double llx, llyy, width, height;

    if (!PyArg_ParseTuple(args, "dddd:gv_view_area_fit_extents", &llx, &llyy, &width, &height))
        return NULL;
    gv_view_area_fit_extents(GV_VIEW_AREA(self->obj), llx, llyy, width, height);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_height_scale
static PyObject *_wrap_gv_view_area_height_scale(PyGObject *self, PyObject *args) {
    double scale;

    if (!PyArg_ParseTuple(args, "d:gv_view_area_height_scale", &scale))
        return NULL;
    gv_view_area_height_scale(GV_VIEW_AREA(self->obj), scale);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_get_height_scale
static PyObject *_wrap_gv_view_area_get_height_scale(PyGObject *self) {
    return PyFloat_FromDouble(gv_view_area_get_height_scale(GV_VIEW_AREA(self->obj)));
}
%%
override gv_records_from_dbf
static PyObject *_wrap_gv_records_from_dbf(PyObject *self, PyObject *args) {
    char *filename;
    GObject *retval;
    PyProgressData sProgressInfo;

    if (!PyArg_ParseTuple(args, "sOO:gv_records_from_dbf", &filename, &(sProgressInfo.psPyCallback), &(sProgressInfo.psPyCallbackData)))
        return NULL;
    retval = (GObject *)gv_records_from_dbf(filename, PyProgressProxy, &sProgressInfo);
    if (retval) return PyGtk_New(retval);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_records_from_rec
static PyObject *_wrap_gv_records_from_rec(PyObject *self, PyObject *args) {
    char *filename;
    GObject *retval;
    PyProgressData sProgressInfo;

    if (!PyArg_ParseTuple(args, "sOO:gv_records_from_rec", &filename, &(sProgressInfo.psPyCallback), &(sProgressInfo.psPyCallbackData)))
        return NULL;
    retval = (GObject *)gv_records_from_rec(filename, PyProgressProxy, &sProgressInfo);
    if (retval) return PyGtk_New(retval);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_have_ogr_support
static PyObject *_wrap_gv_have_ogr_support(PyObject *self) {
    return PyInt_FromLong(gv_have_ogr_support());
}
%%
override gv_shapes_num_shapes
static PyObject *_wrap_gv_shapes_num_shapes(PyGObject *self, PyObject *args) {
    PyGObject *py_shapes;

    if (!PyArg_ParseTuple(args, "O!:gv_shapes_num_shapes", &PyGvShapes_Type,
			  &py_shapes)) {
	return NULL;
    }

    return PyInt_FromLong(gv_shapes_num_shapes(GV_SHAPES(py_shapes->obj)));
}
%%
override gv_points_num_points
static PyObject *_wrap_gv_points_num_points(PyGObject *self, PyObject *args) {
    PyGObject *py_points;

    if (!PyArg_ParseTuple(args, "O!:gv_shapes_num_points", &PyGvPoints_Type,
			  &py_points)) {
	return NULL;
    }

    return PyInt_FromLong(gv_points_num_points(GV_POINTS(py_points->obj)));
}
%%
override gv_polylines_num_lines
static PyObject *_wrap_gv_polylines_num_lines(PyGObject *self, PyObject *args) {
    PyGObject *py_lines;

    if (!PyArg_ParseTuple(args, "O!:gv_shapes_num_lines", &PyGvPolylines_Type,
			  &py_lines)) {
	return NULL;
    }

    return PyInt_FromLong(gv_polylines_num_lines(GV_POLYLINES(py_lines->obj)));
}
%%
override gv_areas_num_areas
static PyObject *_wrap_gv_areas_num_areas(PyGObject *self, PyObject *args) {
    PyGObject *py_areas;

    if (!PyArg_ParseTuple(args, "O!:gv_shapes_num_areas", &PyGvAreas_Type,
			  &py_areas)) {
	return NULL;
    }

    return PyInt_FromLong(gv_areas_num_areas(GV_AREAS(py_areas->obj)));
}
%%
override gv_raster_get_min
static PyObject *_wrap_gv_raster_get_min(PyGObject *self, PyObject *args) {
    PyGObject *py_raster;

    if (!PyArg_ParseTuple(args, "O!:gv_raster_get_min", &PyGvRaster_Type,
			  &py_raster)) {
	return NULL;
    }

    return PyFloat_FromDouble(gv_raster_get_min(GV_RASTER(py_raster->obj)));
}
%%
override gv_raster_get_max
static PyObject *_wrap_gv_raster_get_max(PyGObject *self, PyObject *args) {
    PyGObject *py_raster;

    if (!PyArg_ParseTuple(args, "O!:gv_raster_get_max", &PyGvRaster_Type,
			  &py_raster)) {
	return NULL;
    }

    return PyFloat_FromDouble(gv_raster_get_max(GV_RASTER(py_raster->obj)));
}
%%
override gv_raster_get_dataset
static PyObject *
_wrap_gv_raster_get_dataset(PyGObject *self)
{
    GvRaster *raster;
    char swig_ptr[32];
    GDALDatasetH dataset;

    raster = GV_RASTER(self->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    dataset = raster->dataset;
    if( dataset == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    SWIG_SimpleMakePtr( swig_ptr, dataset, "_GDALDatasetH" );
    return Py_BuildValue("s",swig_ptr);
}
%%
override gv_raster_layer_type_get
static PyObject *_wrap_gv_raster_layer_type_get(PyGObject *self, PyObject *args) {
    int isource;

    if (!PyArg_ParseTuple(args, "i:gv_raster_layer_type_get", &isource))
        return NULL;

    return PyInt_FromLong((long)gv_raster_layer_type_get
			  (GV_RASTER_LAYER(self->obj), isource));
}
%%
override gv_raster_layer_get_source_const_value
static PyObject *_wrap_gv_raster_layer_get_source_const_value(PyGObject *self, PyObject *args)
{
    PyGObject *py_rlayer;
    GvRasterLayer *rlayer;
    PyObject *py_lut;
    int isource=0;

    if (!PyArg_ParseTuple(args, "O!i:gv_raster_layer_get_source_const_value",
			  &PyGvRasterLayer_Type, &py_rlayer, &isource)) {
	return NULL;
    }

    rlayer = GV_RASTER_LAYER(py_rlayer->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    return PyInt_FromLong(gv_raster_layer_get_const_value(rlayer, isource));
}
%%
override gv_build_skirt
static PyObject *_wrap_gv_build_skirt(PyGObject *self, PyObject *args) {
    PyGObject *py_rlayer;
    GvRasterLayer *rlayer;
    double base_z;

    if (!PyArg_ParseTuple(args, "O!d:gv_build_skirt",
			  &PyGvRasterLayer_Type, &py_rlayer, &base_z)) {
	return NULL;
    }

    rlayer = GV_RASTER_LAYER(py_rlayer->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    return PyGtk_New((GObject *)gv_build_skirt(rlayer, base_z));
}
%%
override gv_shape_create
static PyObject *
_wrap_gv_shape_create(PyObject *self, PyObject *args)
{
    int          type;
    char         swig_ptr[32];
    GvShape *shape;

    if (!PyArg_ParseTuple(args, "i:gv_shape_new",
                          &type) )
    return NULL;

    shape = gv_shape_new(type);
    SWIG_SimpleMakePtr( swig_ptr, shape, "_GvShape" );

    return Py_BuildValue("s",swig_ptr);
}
%%
override gv_shape_from_xml
static PyObject *
_wrap_gv_shape_from_xml(PyObject *self, PyObject *args)
{
    GvShape     *shape;
    CPLXMLNode  *cpl_tree;
    PyObject    *py_tree = NULL;

    if (!PyArg_ParseTuple(args, "O!:gv_shape_from_xml",
                          &PyList_Type, &py_tree ) )
        return NULL;

    cpl_tree = PyListToXMLTree( py_tree );
    
    shape = gv_shape_from_xml_tree( cpl_tree );
    if( shape == NULL )
    {
        PyErr_SetString( PyExc_ValueError, 
                         "XML translation to GvShape filed." );
        return NULL;
    }
    else
    {
        char         swig_ptr[32];
        SWIG_SimpleMakePtr( swig_ptr, shape, "_GvShape" );
        return Py_BuildValue("s",swig_ptr);
    }
}
%%
override gv_shape_to_xml
static PyObject *
_wrap_gv_shape_to_xml(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;
    CPLXMLNode *psTree;
    PyObject *py_xml = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_shape_to_xml",
                          &swig_shape_ptr))
        return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape == NULL )
        return NULL;

    psTree = gv_shape_to_xml_tree( shape );
    py_xml = XMLTreeToPyList( psTree );
    CPLDestroyXMLNode( psTree );

    return py_xml;
}
%%
override gv_shape_destroy
static PyObject *
_wrap_gv_shape_destroy(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_shape_destroy",
                          &swig_shape_ptr))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
        gv_shape_delete( shape );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_shape_ref
static PyObject *
_wrap_gv_shape_ref(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_shape_ref",
                          &swig_shape_ptr))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
        gv_shape_ref( shape );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_shape_unref
static PyObject *
_wrap_gv_shape_unref(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_shape_unref",
                          &swig_shape_ptr))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
        gv_shape_unref( shape );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_shape_get_ref
static PyObject *
_wrap_gv_shape_get_ref(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_shape_get_ref",
                          &swig_shape_ptr))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
    {
        return Py_BuildValue( "i", gv_shape_get_ref( shape ) );
    }
    else
    {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gv_shape_copy
static PyObject *
_wrap_gv_shape_copy(PyObject *self, PyObject *args)
{
    char  swig_ptr[32];
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL, *copy = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_shape_copy",
                          &swig_shape_ptr))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
        copy = gv_shape_copy( shape );

    SWIG_SimpleMakePtr( swig_ptr, copy, "_GvShape" );

    return Py_BuildValue("s",swig_ptr);
}
%%
override gv_shape_line_from_nodelists
static PyObject *
_wrap_gv_shape_line_from_nodelists(PyObject *self, PyObject *args)
{
    PyObject *pyxlist=NULL;
    PyObject *pyylist=NULL;
    PyObject *pyzlist=NULL;

    int       node_count, i;
    char         swig_ptr[32];
    GvShape *shape;
    gvgeocoord xnode, ynode, znode;
    int ring=0;

    if (!PyArg_ParseTuple(args, "O!O!O!:gv_shape_line_from_nodelist",
                          &PyList_Type,&pyxlist,
                          &PyList_Type,&pyylist,
                          &PyList_Type,&pyzlist) )
    return NULL;

    node_count=PyList_Size(pyxlist);
    if (node_count < 1)
    {
        PyErr_SetString(PyExc_ValueError,
              "require at least one node in list for gv_shape_line_from_nodelist");
        return NULL;
    }
    if ((node_count != PyList_Size(pyylist)) ||
        (node_count != PyList_Size(pyzlist)))
    {
        PyErr_SetString(PyExc_ValueError,
              "x, y, and z node lists must have identical lengths for gv_shape_line_from_nodelist");
        return NULL;
    }

    shape = gv_shape_new(GVSHAPE_LINE);

    for( i = 0; i < node_count; i++ )
    {
        if ( ( !PyArg_Parse( PyList_GET_ITEM(pyxlist,i), 
                Ccast ":gv_shape_line_from_nodelist" , &xnode ) ) ||
             ( !PyArg_Parse( PyList_GET_ITEM(pyylist,i), 
                Ccast ":gv_shape_line_from_nodelist" , &ynode ) ) ||
             ( !PyArg_Parse( PyList_GET_ITEM(pyzlist,i), 
                Ccast ":gv_shape_line_from_nodelist" , &znode ) ))
        {
            PyErr_SetString(PyExc_ValueError,
          "expecting floats in gv_shape_line_from_nodelist arguments");
            gv_shape_delete(shape);
            return NULL;
        }
        gv_shape_add_node(shape,ring,xnode,ynode,znode);
        
    }

    SWIG_SimpleMakePtr( swig_ptr, shape, "_GvShape" );

    return Py_BuildValue("s",swig_ptr);
}
%%
override gv_shapes_lines_for_vecplot
static PyObject *
_wrap_gv_shapes_lines_for_vecplot(PyObject *self, PyObject *args)
{
    PyObject *pyxlist=NULL;
    PyObject *pyylist=NULL;
    PyObject *pyzlist=NULL;
    PyObject *pyoklist=NULL;

    int       node_count, i, j, last_ok, shape_count,last_shape_nodes, oknode;
    GvShape *shape;
    GvShapes *shapes;
    gvgeocoord xnode, ynode, znode;
    int ring=0;
    int *shape_ids=NULL;

    if (!PyArg_ParseTuple(args, "O!O!O!O!:gv_shapes_lines_for_vecplot",
                          &PyList_Type,&pyxlist,
                          &PyList_Type,&pyylist,
                          &PyList_Type,&pyzlist,
                          &PyList_Type,&pyoklist) )
    return NULL;

    node_count=PyList_Size(pyxlist);
    if (node_count < 1)
    {
        PyErr_SetString(PyExc_ValueError,
              "require at least one node in list for gv_shapes_lines_for_vecplot");
        return NULL;
    }
    if ((node_count != PyList_Size(pyylist)) ||
        (node_count != PyList_Size(pyzlist)) ||
        (node_count != PyList_Size(pyoklist)))
    {
        PyErr_SetString(PyExc_ValueError,
              "x, y, z, ok lists must have identical lengths for gv_shapes_lines_for_vecplot");
        return NULL;
    }
    shapes = (GvShapes *) gv_shapes_new();
    shape = gv_shape_new(GVSHAPE_LINE);
    gv_shapes_add_shape(shapes,shape);
    last_ok=1;
    shape_count=1;
    last_shape_nodes=0;
    for( i = 0; i < node_count; i++ )
    {
        if(( !PyArg_Parse( PyList_GET_ITEM(pyxlist,i), 
              Ccast ":gv_shapes_lines_for_vecplot" , &xnode ) ) ||
           ( !PyArg_Parse( PyList_GET_ITEM(pyylist,i), 
              Ccast ":gv_shapes_lines_for_vecplot" , &ynode ) ) ||
           ( !PyArg_Parse( PyList_GET_ITEM(pyzlist,i), 
              Ccast ":gv_shapes_lines_for_vecplot" , &znode ) ) ||
           ( !PyArg_Parse( PyList_GET_ITEM(pyoklist,i), 
              "i:gv_shapes_lines_for_vecplot" , &oknode ) ))
        {
            PyErr_SetString(PyExc_ValueError,
          "expecting floats for nodes, ints for ok in gv_shapes_lines_for_vecplot arguments");
            shape_ids=g_new(int,shape_count);
            for ( j= 0 ; j < shape_count; j++ )
            {
                *(shape_ids+sizeof(int)) = j;
            }
            gv_shapes_delete_shapes(shapes,shape_count,shape_ids);
            g_free(shape_ids);
            return NULL;
        }
        if (oknode == 1)
        {
            gv_shape_add_node(shape,ring,xnode,ynode,znode);
            last_ok = 1;
            last_shape_nodes=last_shape_nodes+1;
        }
        else if (last_ok == 1)
        {
            shape=gv_shape_new(GVSHAPE_LINE);
            gv_shapes_add_shape(shapes,shape);
            shape_count=shape_count+1;
            last_shape_nodes=0;
            last_ok = 0;
        } 
    }
    if (last_shape_nodes == 0)
    {
        shape_ids=g_new(int,1);
        *shape_ids=shape_count-1;
        gv_shapes_delete_shapes(shapes,1,shape_ids);
        g_free(shape_ids);
    }

    return PyGtk_New((GObject *) shapes);
}
%%
override gv_shape_get_property
static PyObject *
_wrap_gv_shape_get_property(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    char *key;
    GvShape *shape = NULL;
    const char *value = NULL;

    if (!PyArg_ParseTuple(args, "ss:gv_shape_get_property",
                          &swig_shape_ptr, &key))
        return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
        value = gv_properties_get( gv_shape_get_properties( shape ), key );

    if( value != NULL )
        return Py_BuildValue( "s", value );
    else
    {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gv_shape_get_properties
static PyObject *
_wrap_gv_shape_get_properties(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;
    GvProperties *properties = NULL;
    PyObject *psDict = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_shape_get_properties",
                          &swig_shape_ptr))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
        properties = gv_shape_get_properties( shape );

    psDict = PyDict_New();
    if( properties != NULL )
    {
        int        i, count;

        count = gv_properties_count( properties );
        for( i = 0; i < count; i++ )
        {
            const char *value, *name;
            PyObject *py_name, *py_value;

            value = gv_properties_get_value_by_index(properties,i);
            name = gv_properties_get_name_by_index(properties,i);

            py_name = Py_BuildValue("s",name);
            py_value = Py_BuildValue("s",value);
            PyDict_SetItem( psDict, py_name, py_value );

            Py_DECREF(py_name);
            Py_DECREF(py_value);
        }
    }

    return psDict;
}
%%
override gv_shape_get_typed_properties
static PyObject *
_wrap_gv_shape_get_typed_properties(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;
    GvProperties *properties = NULL;
    PyObject *psDict = NULL;
    PyObject *pyFieldList = NULL;
    int      nCount, i;

    if (!PyArg_ParseTuple(args, "sO!:get_typed_properties",
                          &swig_shape_ptr, &PyList_Type, &pyFieldList))
        return NULL;

    if( swig_shape_ptr )
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );

    if( shape != NULL )
        properties = gv_shape_get_properties( shape );

    psDict = PyDict_New();
    if( properties == NULL )
        return psDict;

    nCount = PyList_Size(pyFieldList);
    for( i = 0; i < nCount; i++ )
    {
        char *pszFieldName = NULL;
        int nNumericFlag = 0;
        const char *value;
        PyObject *py_name, *py_value;

        if( !PyArg_Parse( PyList_GET_ITEM(pyFieldList,i), "(si)",
                          &pszFieldName, &nNumericFlag ) )
        {
            PyErr_SetString(PyExc_ValueError,
                            "expecting (name,flag) tuples in list.");
            return NULL;
        }

        value = gv_properties_get(properties,pszFieldName);
        if( value == NULL )
        {
            py_value = Py_None;
            Py_INCREF( Py_None );
        }
        else if( nNumericFlag )
            py_value = Py_BuildValue("f",atof(value));
        else
            py_value = Py_BuildValue("s",value);

        py_name = Py_BuildValue("s",pszFieldName);

        PyDict_SetItem( psDict, py_name, py_value );

        Py_DECREF(py_name);
        Py_DECREF(py_value);
    }

    return psDict;
}
%%
override gv_shape_set_property
static PyObject *
_wrap_gv_shape_set_property(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL, *name=NULL, *value=NULL;
    GvShape *shape = NULL;
    GvProperties *properties = NULL;

    if (!PyArg_ParseTuple(args, "sss:gv_shape_set_property",
                          &swig_shape_ptr, &name, &value))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
    {
        properties = gv_shape_get_properties( shape );
        gv_properties_set( properties, name, value );
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_shape_set_properties
static PyObject *
_wrap_gv_shape_set_properties(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;
    GvProperties *properties = NULL;
    PyObject *psDict = NULL;
    PyObject    *pyKey = NULL, *pyValue = NULL;

    if (!PyArg_ParseTuple(args, "sO!:gv_shape_set_properties",
                          &swig_shape_ptr, &PyDict_Type, &psDict))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
    {
        int i;

        properties = gv_shape_get_properties( shape );

        gv_properties_clear( properties );

        i = 0;
        while( PyDict_Next( psDict, &i, &pyKey, &pyValue ) )
        {
            char            *key = NULL, *value = NULL;

            if( !PyArg_Parse( pyKey, "s", &key )
                || !PyArg_Parse( pyValue, "s", &value ))
                continue;

            gv_properties_set( properties, key, value );

            pyKey = pyValue = NULL;
        }
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_shape_get_shape_type
static PyObject *
_wrap_gv_shape_get_shape_type(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_shape_get_shape_type",
                          &swig_shape_ptr))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
        return Py_BuildValue("i", gv_shape_type(shape));
    else
        return NULL;
}
%%
override gv_shape_get_rings
static PyObject *
_wrap_gv_shape_get_rings(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_shape_get_rings",
                          &swig_shape_ptr))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
        return Py_BuildValue("i",gv_shape_get_rings(shape));
    else
        return NULL;
}
%%
override gv_shape_get_nodes
static PyObject *
_wrap_gv_shape_get_nodes(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;
    int      ring = 0;

    if (!PyArg_ParseTuple(args, "si:gv_shape_get_nodes",
                          &swig_shape_ptr, &ring))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
        return Py_BuildValue("i",gv_shape_get_nodes(shape,ring));
    else
        return NULL;
}
%%
override gv_shape_add_node
static PyObject *
_wrap_gv_shape_add_node(PyObject *self, PyObject *args)
{
    char      *swig_shape_ptr = NULL;
    GvShape   *shape = NULL;
    int        ring = 0;
    gvgeocoord x=0.0, y=0.0, z=0.0;

    if (!PyArg_ParseTuple(args, "s" CCC "i:gv_shape_add_node", &swig_shape_ptr,
                          &x, &y, &z, &ring ))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
        return Py_BuildValue("i",gv_shape_add_node(shape,ring, x,y,z));
    else
        return NULL;
}
%%
override gv_shape_set_node
static PyObject *
_wrap_gv_shape_set_node(PyObject *self, PyObject *args)
{
    char      *swig_shape_ptr = NULL;
    GvShape   *shape = NULL;
    int        ring = 0, node = 0;
    gvgeocoord x=0.0, y=0.0, z=0.0;

    if (!PyArg_ParseTuple(args, "s" CCC "ii:gv_shape_set_node", &swig_shape_ptr,
                          &x, &y, &z, &node, &ring ))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL )
        return Py_BuildValue("i",
                       gv_shape_set_xyz(shape, ring, node, x,y,z));
    else
        return NULL;
}
%%
override gv_shape_get_node
static PyObject *
_wrap_gv_shape_get_node(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;
    int      ring = 0, node = 0;

    if (!PyArg_ParseTuple(args, "sii:gv_shape_get_node",
                          &swig_shape_ptr, &node, &ring ))
    return NULL;

    if( swig_shape_ptr )
    {
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if( shape != NULL ){
        return Py_BuildValue("(" CCC ")",
                             gv_shape_get_x(shape,ring,node),
                             gv_shape_get_y(shape,ring,node),
                             gv_shape_get_z(shape,ring,node) );
    }else
        return NULL;
}
%%
override gv_shape_point_in_polygon
static PyObject *
_wrap_gv_shape_point_in_polygon(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;
    double  x, y;

    if (!PyArg_ParseTuple(args, "sdd:gv_shape_point_in_polygon",
                          &swig_shape_ptr, &x, &y ))
        return NULL;

    if( swig_shape_ptr )
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );

    if( shape != NULL )
        return Py_BuildValue("i", gv_shape_point_in_polygon(shape, x, y ));
    else
        return NULL;
}
%%
override gv_shape_distance_from_polygon
static PyObject *
_wrap_gv_shape_distance_from_polygon(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;
    double  x, y;

    if (!PyArg_ParseTuple(args, "sdd:gv_shape_distance_from_polygon",
                          &swig_shape_ptr, &x, &y ))
        return NULL;

    if( swig_shape_ptr )
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );

    if( shape != NULL )
        return Py_BuildValue("d", gv_shape_distance_from_polygon(shape, x, y ));
    else
        return NULL;
}
%%
override gv_shape_clip_to_rect
static PyObject *
_wrap_gv_shape_clip_to_rect(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;
    double  x, y, width, height;

    if (!PyArg_ParseTuple(args, "sdddd:gv_shape_clip_to_rect",
                          &swig_shape_ptr, &x, &y, &width, &height ))
        return NULL;

    if( swig_shape_ptr )
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );

    if( shape != NULL )
    {
        GvRect      rect;
        GvShape *new_shape;

        rect.x = x;
        rect.y = y;
        rect.width = width;
        rect.height = height;

        new_shape = gv_shape_clip_to_rect( shape, &rect );

        if( new_shape == NULL )
        {
            Py_INCREF(Py_None);
            return Py_None;
        }
        else
        {
            char swig_ptr[128];

            SWIG_SimpleMakePtr( swig_ptr, new_shape, "_GvShape" );

            return Py_BuildValue("s",swig_ptr);
        }
    }
    else
        return NULL;
}
%%
override gv_shape_add_shape
static PyObject *
_wrap_gv_shape_add_shape(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    char *swig_sub_shape_ptr = NULL;
    GvShape *shape = NULL, *sub_shape = NULL;

    if (!PyArg_ParseTuple(args, "ss:gv_shape_add_shape",
                          &swig_shape_ptr, &swig_sub_shape_ptr ))
        return NULL;

    if( swig_shape_ptr )
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );

    if( swig_sub_shape_ptr )
        sub_shape = SWIG_SimpleGetPtr( swig_sub_shape_ptr, "_GvShape" );

    if( shape != NULL && sub_shape != NULL )
        gv_shape_collection_add_shape( shape, sub_shape );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_shape_get_shape
static PyObject *
_wrap_gv_shape_get_shape(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;
    int shape_index;

    if (!PyArg_ParseTuple(args, "si:gv_shape_get_shape",
                          &swig_shape_ptr, &shape_index ))
        return NULL;

    if( swig_shape_ptr )
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );

    if( shape == NULL )
    {
        PyErr_SetString(PyExc_ValueError, "no shape passed into get_shape().");
        return NULL;
    }

    shape = gv_shape_collection_get_shape( shape, shape_index );
    if( shape == NULL )
    {
        PyErr_SetString(PyExc_IndexError, "shape index out of range for collection");
        return NULL;
    }
    else
    {
        char swig_ptr[128];
        
        SWIG_SimpleMakePtr( swig_ptr, shape, "_GvShape" );
        
        return Py_BuildValue("s",swig_ptr);
    }
}
%%
override gv_shape_collection_get_count
static PyObject *
_wrap_gv_shape_collection_get_count(PyObject *self, PyObject *args)
{
    char *swig_shape_ptr = NULL;
    GvShape *shape = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_shape_collection_get_count",
                          &swig_shape_ptr ))
        return NULL;

    if( swig_shape_ptr )
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );

    if( shape == NULL )
    {
        PyErr_SetString(PyExc_ValueError, "no shape passed into get_shape().");
        return NULL;
    }

    return Py_BuildValue( "i", gv_shape_collection_get_count( shape ) );
}
%%
override gv_symbol_manager_get_names
static PyObject *
_wrap_gv_symbol_manager_get_names(PyGObject *self, PyObject *args)
{
    PyObject *py_name_list;
    GvSymbolManager *manager;
    char **name_list;
    int i, count;

    manager = GV_SYMBOL_MANAGER(self->obj);
    if (!GV_IS_SYMBOL_MANAGER(manager)) {
	PyErr_SetString(PyExc_TypeError, "manager argument must be a GvSymbolManager");
	return NULL;
    }
    name_list = gv_symbol_manager_get_names(manager);
    
    count = CSLCount( name_list );
    py_name_list = PyList_New( count );
    for( i = 0; i < count; i++ )
        PyList_SetItem( py_name_list, i, Py_BuildValue( "s", name_list[i] ) );
    
    g_free( name_list );

    return py_name_list;
}
%%
override gv_symbol_manager_inject_vector_symbol
static PyObject *
_wrap_gv_symbol_manager_inject_vector_symbol(PyGObject *self, PyObject *args)
{
    GvSymbolManager *manager;
    GvShape  *shape = NULL;
    char     *swig_shape_ptr = NULL;
    char     *symbol_name = NULL;

    if (!PyArg_ParseTuple(args, "ss:gv_symbol_manager_inject_vector_symbol",
                          &symbol_name, &swig_shape_ptr )) {
        return NULL;
    }

    manager = GV_SYMBOL_MANAGER(self->obj);
    if (!GV_IS_SYMBOL_MANAGER(manager)) {
	PyErr_SetString(PyExc_TypeError, "manager argument must be a GvSymbolManager");
	return NULL;
    }

    if( swig_shape_ptr )
        shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );

    if( shape ) {
        gv_symbol_manager_inject_vector_symbol(manager, symbol_name, shape);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_symbol_manager_inject_raster_symbol
static PyObject *
_wrap_gv_symbol_manager_inject_raster_symbol(PyGObject *self, PyObject *args)
{
    GvSymbolManager *manager;
    char     *rgba_string = NULL;
    char     *symbol_name = NULL;
    int      width, height, rgba_len;

    if (!PyArg_ParseTuple(args,
                          "siiz#:gv_symbol_manager_inject_raster_symbol",
                          &symbol_name, &width, &height, &rgba_string, &rgba_len )) {
        return NULL;
    }

    manager = GV_SYMBOL_MANAGER(self->obj);
    if (!GV_IS_SYMBOL_MANAGER(manager)) {
	PyErr_SetString(PyExc_TypeError, "manager argument must be a GvSymbolManager");
	return NULL;
    }

    if( width*height*4 > rgba_len )
    {
        PyErr_SetString(PyExc_TypeError,
                        "rgba raster symbol buffer seems to be too small (width*height*4)\nin gv_symbol_manager_inject_raster_symbol()." );
        return NULL;
    }

    gv_symbol_manager_inject_raster_symbol(manager, symbol_name,
					   width, height, rgba_string );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_symbol_manager_get_symbol
static PyObject *
_wrap_gv_symbol_manager_get_symbol(PyGObject *self, PyObject *args)
{
    GvSymbolManager *manager;
    char     *symbol_name = NULL;
    GvSymbolObj *symbol;

    if (!PyArg_ParseTuple(args,"s:gv_symbol_manager_get_symbol", &symbol_name ))
        return NULL;

    manager = GV_SYMBOL_MANAGER(self->obj);
    if (!GV_IS_SYMBOL_MANAGER(manager)) {
	PyErr_SetString(PyExc_TypeError, "manager argument must be a GvSymbolManager");
	return NULL;
    }

    symbol = gv_symbol_manager_get_symbol(manager, symbol_name );

    if( symbol == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    if( symbol->type == GV_SYMBOL_VECTOR )
    {
        char      swig_shape_ptr[32];

        SWIG_SimpleMakePtr( swig_shape_ptr, symbol->buffer, "_GvShape" );

        return Py_BuildValue("(is)", symbol->type, swig_shape_ptr );
    }
    else
    {
        PyObject *py_rgba_buffer;
        PyObject *py_result;

        py_rgba_buffer =
            PyString_FromStringAndSize( symbol->buffer,
                                        symbol->width * symbol->height * 4 );

        py_result = Py_BuildValue("(iiiO)",
                                  symbol->type, symbol->width, symbol->height,
                                  py_rgba_buffer );
        Py_DECREF( py_rgba_buffer );

        return py_result;
    }
}
%%
override gv_data_get_properties
static PyObject *
_wrap_gv_data_get_properties(PyGObject *self, PyObject *args)
{
    GvData *data;
    GvProperties *properties = NULL;
    PyObject *psDict = NULL;

    data = GV_DATA(self->obj);
    if (!GV_IS_DATA(data)) {
	PyErr_SetString(PyExc_TypeError, "data argument must be a GvData object");
	return NULL;
    }

    properties = gv_data_get_properties(data);

    psDict = PyDict_New();
    if( properties != NULL )
    {
        int        i, count;

        count = gv_properties_count( properties );
        for( i = 0; i < count; i++ )
        {
            const char *value, *name;
            PyObject *py_name, *py_value;

            value = gv_properties_get_value_by_index(properties,i);
            name = gv_properties_get_name_by_index(properties,i);

            py_name = Py_BuildValue("s",name);
            py_value = Py_BuildValue("s",value);
            PyDict_SetItem( psDict, py_name, py_value );

            Py_DECREF(py_name);
            Py_DECREF(py_value);
        }
    }

    return psDict;
}
%%
override gv_data_set_properties
static PyObject *
_wrap_gv_data_set_properties(PyGObject *self, PyObject *args)
{
    PyGObject *py_data;
    GvData *data;
    GvProperties *properties = NULL;
    PyObject *psDict = NULL;
    PyObject    *pyKey = NULL, *pyValue = NULL;
    int ii;


    if (!PyArg_ParseTuple(args, "O!O!:gv_data_set_properties", &PyGvData_Type,
			  &py_data, &PyDict_Type, &psDict)) {
	return NULL;
    }

    data = GV_DATA(py_data->obj);
    if (!GV_IS_DATA(data)) {
	PyErr_SetString(PyExc_TypeError, "data argument must be a GvData object");
	return NULL;
    }

    properties = gv_data_get_properties(data);

    gv_properties_clear( properties );

    ii = 0;
    while( PyDict_Next( psDict, &ii, &pyKey, &pyValue ) )
    {
        char *key = NULL, *value = NULL;

        if( !PyArg_Parse( pyKey, "s", &key )
            || !PyArg_Parse( pyValue, "s", &value ))
            continue;

        gv_properties_set( properties, key, value );

        pyKey = pyValue = NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_layer_extents
static PyObject *
_wrap_gv_layer_extents(PyGObject *self, PyObject *args)
{
    GvLayer *layer;
    GvRect rect;

    layer = GV_LAYER(self->obj);
    if (!GV_IS_LAYER(layer)) {
	PyErr_SetString(PyExc_TypeError, "layer argument must be a GvLayer");
	return NULL;
    }

    gv_layer_extents(layer, &rect);

    return Py_BuildValue( "(" CCCC ")", rect.x, rect.y, rect.width, rect.height);
}
%%
override gv_layer_display_change
static PyObject *
_wrap_gv_layer_display_change(PyGObject *self, PyObject *args)
{
    GvLayer *layer;

    layer = GV_LAYER(self->obj);
    if (!GV_IS_LAYER(layer)) {
	PyErr_SetString(PyExc_TypeError, "layer argument must be a GvLayer");
	return NULL;
    }

    gv_layer_display_change(layer, NULL );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_list_layers
static PyObject *
_wrap_gv_view_area_list_layers(PyGObject *self, PyObject *args)
{
    PyObject *py_list;
    GvViewArea *view;
    GList *list;

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }

    py_list = PyList_New(0);
    for (list = gv_view_area_list_layers(view); list != NULL; list = list->next)
    {
        PyObject *layer = PyGtk_New(G_OBJECT(list->data));
        PyList_Append(py_list, layer);
        Py_DECREF(layer);
    }
    g_list_free(list);
    return py_list;
}
%%
override gv_view_area_get_translation
static PyObject *
_wrap_gv_view_area_get_translation(PyGObject *self, PyObject *args)
{
    PyGObject *py_view;
    GvViewArea *view;

    if (!PyArg_ParseTuple(args, "O!:gv_view_area_get_translation",
			  &PyGvViewArea_Type, &py_view)) {
	return NULL;
    }

    view = GV_VIEW_AREA(py_view->obj);

    return Py_BuildValue( "(" CC ")", view->state.tx, view->state.ty );
}
%%
override gv_view_area_map_location
static PyObject *
_wrap_gv_view_area_map_location(PyGObject *self, PyObject *args)
{
    GvViewArea *view;
    gvgeocoord  x, y;

    if (!PyArg_ParseTuple(args, "(" CC "):gv_view_area_map_location",
                          &x, &y))
    {
	return NULL;
    }

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }

    gv_view_area_map_location( view, x, y, &x, &y );

    return Py_BuildValue("(" CC ")", x, y );
}
%%
override gv_view_area_get_pointer
static PyObject *
_wrap_gv_view_area_get_pointer(PyGObject *self, PyObject *args)
{
    GvViewArea *view;
    gvgeocoord  x, y;

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }
    gv_view_area_map_pointer(view, view->state.mpos_x,
			     view->state.mpos_y, &x, &y );

    return Py_BuildValue("(" CC ")", x, y );
}
%%
override gv_view_area_map_pointer
static PyObject *
_wrap_gv_view_area_map_pointer(PyGObject *self, PyObject *args)
{
    GvViewArea *view;
    gvgeocoord  x, y;

    if (!PyArg_ParseTuple(args, "(" CC "):gv_view_area_map_pointer",
			  &x, &y))
    {
	return NULL;
    }

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }
    gv_view_area_map_pointer( view, x, y, &x, &y );

    return Py_BuildValue("(" CC ")", x, y );
}
%%
override gv_view_area_get_extents
static PyObject *
_wrap_gv_view_area_get_extents(PyGObject *self, PyObject *args)
{
    GvViewArea *view;
    gvgeocoord xmin, ymin, xmax, ymax;

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }
    gv_view_area_get_extents( view, &xmin, &ymin, &xmax, &ymax );

    return Py_BuildValue("(" CCCC ")", xmin, ymin, xmax, ymax );
}
%%
override gv_view_area_get_volume
static PyObject *
_wrap_gv_view_area_get_volume(PyGObject *self)
{
    GvViewArea *view;
    double  volume[6];

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }
    gv_view_area_get_volume( view, volume );

    return Py_BuildValue("(" CCCCCC ")",
                         volume[0], volume[1],
                         volume[2], volume[3],
                         volume[4], volume[5] );
}

%%
override gv_view_area_inverse_map_pointer
static PyObject *
_wrap_gv_view_area_inverse_map_pointer(PyGObject *self, PyObject *args)
{
    GvViewArea *view;
    gvgeocoord x, y;

    if (!PyArg_ParseTuple(args, "(" CC "):gv_view_area_inverse_map_pointer",
                          &x, &y))
    {
    return NULL;
    }

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }
    gv_view_area_inverse_map_pointer( view, x, y, &x, &y );

    return Py_BuildValue("(" CC ")", x, y );
}
%%
override gv_view_area_get_fontnames
static PyObject *
_wrap_gv_view_area_get_fontnames(PyGObject *self, PyObject *args)
{
    GvViewArea *view;
    GPtrArray *g_list;
    PyObject  *py_list;
    int       i;

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }

    g_list = gv_view_area_get_fontnames(view);

    py_list = PyList_New(0);
    for( i = 0; i < g_list->len; i++ )
    {
        const char  *item = (const char *) g_ptr_array_index(g_list,i);
        PyObject    *py_item;

        py_item = Py_BuildValue( "s", item );
        PyList_Append( py_list, py_item );
        Py_DECREF( py_item );
    }

    g_ptr_array_free( g_list, FALSE );

    return py_list;
}
%%
override gv_view_area_set_background_color
static PyObject *
_wrap_gv_view_area_set_background_color(PyGObject *self, PyObject *args)
{
    GvViewArea *view;
    GvColor color;

    if (!PyArg_ParseTuple(args, "(ffff):gv_view_area_set_background_color",
			  &color[0], &color[1], &color[2], &color[3])) {
	return NULL;
    }

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }

    gv_view_area_set_background_color(view, color);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_get_background_color
static PyObject *
_wrap_gv_view_area_get_background_color(PyGObject *self, PyObject *args)
{
    GvViewArea *view;
    GvColor color;

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }

    gv_view_area_get_background_color(view, color);

    return Py_BuildValue("(ffff)", color[0], color[1], color[2], color[3] );
}
%%
override gv_view_area_set_3d_view
static PyObject *
_wrap_gv_view_area_set_3d_view(PyGObject *self, PyObject *args)
{
    GvViewArea *view;
    vec3_t     eye_pos, eye_dir;

    if (!PyArg_ParseTuple(args,  "(" CCC ")(" CCC "):gv_view_area_set_3d_view",
                          eye_pos+0, eye_pos+1, eye_pos+2,
                          eye_dir+0, eye_dir+1, eye_dir+2))
    {
	return NULL;
    }

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }

    gv_view_area_set_3d_view( view, eye_pos, eye_dir );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_set_3d_view_look_at
static PyObject *
_wrap_gv_view_area_set_3d_view_look_at(PyGObject *self, PyObject *args)
{
    GvViewArea *view;
    vec3_t     eye_pos;
    gvgeocoord eye_look_at[2];

    if (!PyArg_ParseTuple(args, "(" CCC ")(" CC "):gv_view_area_set_3d_view_look_at",
                          eye_pos+0, eye_pos+1, eye_pos+2,
                          eye_look_at+0, eye_look_at+1))
	{
	    return NULL;
	}

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }

    gv_view_area_set_3d_view_look_at( view, eye_pos, eye_look_at );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_view_area_get_eye_pos
static PyObject *
_wrap_gv_view_area_get_eye_pos(PyGObject *self, PyObject *args)
{
    PyGObject *py_view;
    GvViewArea *view;

    if (!PyArg_ParseTuple(args, "O!:gv_view_area_get_pos", &PyGvViewArea_Type,
			  &py_view)) {
	return NULL;
    }

    view = GV_VIEW_AREA(py_view->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }

    return Py_BuildValue( "(" CCC ")",
                          view->state.eye_pos[0],
                          view->state.eye_pos[1],
                          view->state.eye_pos[2] );
}
%%
override gv_view_area_get_eye_dir
static PyObject *
_wrap_gv_view_area_get_eye_dir(PyGObject *self, PyObject *args)
{
    PyGObject *py_view;
    GvViewArea *view;

    if (!PyArg_ParseTuple(args, "O!:gv_view_area_get_eye_dir",
			  &PyGvViewArea_Type, &py_view)) {
	return NULL;
    }

    view = GV_VIEW_AREA(py_view->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }

    return Py_BuildValue( "(" CCC ")",
                          view->state.eye_dir[0],
                          view->state.eye_dir[1],
                          view->state.eye_dir[2] );
}
%%
override gv_view_area_get_look_at_pos
static PyObject *
_wrap_gv_view_area_get_look_at_pos(PyGObject *self, PyObject *args)
{
    GvViewArea *view;
    gvgeocoord  x, y;

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }

    if (!gv_view_area_get_look_at_pos( view, &x, &y))
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return Py_BuildValue("(" CC ")", x, y);

}
%%
override gv_roi_tool_get_rect
static PyObject *
_wrap_gv_roi_tool_get_rect(PyGObject *self, PyObject *args)
{
    GvRect rect;
    GvRoiTool *tool;

    tool = GV_ROI_TOOL(self->obj);
    if (!GV_IS_ROI_TOOL(tool)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRoiTool");
	return NULL;
    }

    if (!gv_roi_tool_get_rect(tool, &rect)) {
        PyErr_SetString(PyExc_RuntimeError, "no ROI marked");
        return NULL;
    }

    return Py_BuildValue("(" CCCC ")", rect.x, rect.y, rect.width, rect.height);
}
%%
override gv_roi_tool_new_rect
static PyObject *
_wrap_gv_roi_tool_new_rect(PyGObject *self, PyObject *args)
{
    GvRect rect;
    GvRoiTool *tool;

    if (!PyArg_ParseTuple(args, "(" CCCC "):gv_roi_tool_new_rect",
			  &rect.x, &rect.y, &rect.width, &rect.height)) {
	return NULL;
    }

    tool = GV_ROI_TOOL(self->obj);
    if (!GV_IS_ROI_TOOL(tool)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRoiTool");
	return NULL;
    }

    if (!gv_roi_tool_new_rect(tool, &rect)){
	PyErr_SetString(PyExc_RuntimeError, "invalid ROI specified");
	return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_poi_tool_get_point
static PyObject *
_wrap_gv_poi_tool_get_point(PyGObject *self, PyObject *args)
{
    GvVertex point;
    GvPoiTool *tool;

    tool = GV_POI_TOOL(self->obj);
    if (!GV_IS_POI_TOOL(tool)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvPoiTool");
	return NULL;
    }

    if (!gv_poi_tool_get_point(tool, &point)) {
	PyErr_SetString(PyExc_RuntimeError, "no POI marked");
	return NULL;
    }

    return Py_BuildValue("(" CC ")", point.x, point.y);
}
%%
override gv_poi_tool_new_point
static PyObject *
_wrap_gv_poi_tool_new_point(PyGObject *self, PyObject *args)
{
    GvVertex point;
    GvPoiTool *tool;

    if (!PyArg_ParseTuple(args, "(" CC "):gv_poi_tool_new_point",
			  &point.x, &point.y)) {
	return NULL;
    }

    tool = GV_POI_TOOL(self->obj);
    if (!GV_IS_POI_TOOL(tool)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvPoiTool");
	return NULL;
    }

    if (!gv_poi_tool_new_point(tool, &point)) {
        PyErr_SetString(PyExc_RuntimeError, "invalid POI specified");
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_tool_set_boundary
static PyObject *
_wrap_gv_tool_set_boundary(PyGObject *self, PyObject *args)
{
    GvRect rect;
    GvTool *tool;

    if (!PyArg_ParseTuple(args, "(" CCCC "):gv_tool_set_boundary",
                          &rect.x, &rect.y, &rect.width, &rect.height)) {
        return NULL;
    }

    tool = GV_TOOL(self->obj);
    if (!GV_IS_TOOL(tool)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvTool");
	return NULL;
    }

    if (!gv_tool_set_boundary(tool, &rect)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "invalid ROI constraining region specified, width or height <= 0.0");
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_records_set_used_properties
static PyObject *
_wrap_gv_records_set_used_properties(PyGObject *self, PyObject *args)
{
    PyObject *py_list;
    GvRecords *records;
    int       nFieldCount, *panFieldList = NULL, i;

    if (!PyArg_ParseTuple(args, "O!:gv_records_set_used_properties",
                          &PyList_Type, &py_list) )
        return NULL;

    if(!GV_IS_RECORDS(self->obj)) return NULL;
    records = GV_RECORDS(self->obj);
    
    nFieldCount = PyList_Size(py_list);
    panFieldList = g_new( int, nFieldCount );

    for( i = 0; i < nFieldCount; i++ )
    {
        if( !PyArg_Parse( PyList_GET_ITEM(py_list,i), "i", panFieldList + i ) )
        {
            PyErr_SetString(PyExc_ValueError,
                            "expecting ints in gv_records_set_used_fields argument");
            return NULL;
        }
    }

    gv_records_set_used_properties( records, nFieldCount, panFieldList );

    g_free( panFieldList );
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_records_get_typed_properties
static PyObject *
_wrap_gv_records_get_typed_properties(PyGObject *self, PyObject *args)
{
    int       shp_index = -1, iField, ii;
    GvRecords *records;
    const char *pachRecData;
    PyObject *psDict = NULL;

    if (!PyArg_ParseTuple(args, "i:gv_records_get_typed_properties",
                          &shp_index)) {
        return NULL;
    }

    if(!GV_IS_RECORDS(self->obj)) return NULL;
    records = GV_RECORDS(self->obj);

    if( shp_index < 0 || shp_index >= records->nRecordCount )
        return NULL;

    psDict = PyDict_New();
    pachRecData = gv_records_get_raw_record_data( records, shp_index );
    for( ii = 0; ii < records->nUsedFieldCount; ii++ )
    {
        PyObject *py_name, *py_value;
        const char *value;

        iField = records->panUsedFieldList[ii];

        value = pachRecData + records->panFieldOffset[iField];

        if( *value == GV_NULL_MARKER )
        {
            py_value = Py_None;
            Py_INCREF( Py_None );
        }
        else if( records->panFieldType[iField] == GV_RFT_INTEGER )
            py_value = Py_BuildValue("i",atoi(value));
        else if( records->panFieldType[iField] == GV_RFT_FLOAT )
            py_value = Py_BuildValue("f",atof(value));
        else
            py_value = Py_BuildValue("s",value);
        
        py_name = Py_BuildValue("s",records->papszFieldName[iField]);

        PyDict_SetItem( psDict, py_name, py_value );

        Py_DECREF(py_name);
        Py_DECREF(py_value);
    }

    return psDict;
}
%%
override gv_records_get_properties
static PyObject *
_wrap_gv_records_get_properties(PyGObject *self, PyObject *args)
{
    int       shp_index = -1, iField;
    GvRecords *records;
    const char *pachRecData;
    PyObject *psDict = NULL;

    if (!PyArg_ParseTuple(args, "i:gv_records_get_properties",
                          &shp_index) )
        return NULL;

    if(!GV_IS_RECORDS(self->obj)) return NULL;
    records = GV_RECORDS(self->obj);

    if( shp_index < 0 || shp_index >= records->nRecordCount )
        return NULL;

    psDict = PyDict_New();
    pachRecData = gv_records_get_raw_record_data( records, shp_index );
    for( iField = 0; iField < records->nFieldCount; iField++ )
    {
        PyObject *py_name, *py_value;
        const char *value;

        value = pachRecData + records->panFieldOffset[iField];
        if( *value == GV_NULL_MARKER )
            continue;

        py_value = Py_BuildValue("s",value);
        py_name = Py_BuildValue("s",records->papszFieldName[iField]);

        PyDict_SetItem( psDict, py_name, py_value );

        Py_DECREF(py_name);
        Py_DECREF(py_value);
    }

    return psDict;
}
%%
override gv_records_to_dbf
static PyObject *
_wrap_gv_records_to_dbf(PyGObject *self, PyObject *args)
{
    PyObject *py_list;
    char      *filename = NULL;
    GvRecords *records;
    int       nSelectionCount, *panSelectionList = NULL, i, result;
    PyProgressData sProgressInfo;

    sProgressInfo.psPyCallback = NULL;
    sProgressInfo.psPyCallbackData = NULL;

    if (!PyArg_ParseTuple(args, "sO!OO:gv_records_to_dbf",
                          &filename, &PyList_Type, &py_list,
                          &(sProgressInfo.psPyCallback),
                          &(sProgressInfo.psPyCallbackData) ) )
        return NULL;

    if(!GV_IS_RECORDS(self->obj)) return NULL;
    records = GV_RECORDS(self->obj);

    nSelectionCount = PyList_Size(py_list);
    if( nSelectionCount != 0 )
        panSelectionList = g_new( int, nSelectionCount );

    for( i = 0; i < nSelectionCount; i++ )
    {
        if( !PyArg_Parse( PyList_GET_ITEM(py_list,i), "i", panSelectionList + i ) )
        {
            PyErr_SetString(PyExc_ValueError,
                            "expecting ints in gv_records_to_dbf argument");
            return NULL;
        }
    }

    result = gv_records_to_dbf( records, filename, 
                                nSelectionCount, panSelectionList,
                                PyProgressProxy, &sProgressInfo );

    g_free( panSelectionList );
    
    return Py_BuildValue("i", result );
}
%%
override gv_shapes_from_ogr_layer
static PyObject *
_wrap_gv_shapes_from_ogr_layer(PyObject *self, PyObject *args)
{
    GvData    *data = NULL;
    char      *ogrlayer_in = NULL;
    void      *hLayer;
    PyObject *py_ret = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_shapes_from_ogr_layer",
                          &ogrlayer_in) )
        return NULL;

    hLayer = SWIG_SimpleGetPtr(ogrlayer_in, "OGRLayerH" );
    if( hLayer == NULL )
    {
        PyErr_SetString(PyExc_IOError,
                        "Unable to extract OGRLayerH handle in gv_shapes_from_ogr_layer()");
        return NULL;
    }

    data = gv_shapes_from_ogr_layer( hLayer );
    if( data == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    py_ret = PyGtk_New( G_OBJECT(data) );

    /* PENDING - Do we need this anymore?
    gtk_object_sink( GTK_OBJECT(data) );
    */

    return py_ret;
}
%%
override gv_shapes_get_shape
static PyObject *
_wrap_gv_shapes_get_shape(PyGObject *self, PyObject *args)
{
    PyGObject *py_shapes;
    GvShapes *shapes;
    int       shp_index = -1;
    char      swig_shape_ptr[32];
    GvShape   *gv_shape = NULL;

    if (!PyArg_ParseTuple(args, "O!i:gv_shapes_get_shape", &PyGvShapes_Type,
			  &py_shapes, &shp_index) ) {
        return NULL;
    }

    shapes = GV_SHAPES(py_shapes->obj);
    if (!GV_IS_SHAPES(shapes)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvShapes");
	return NULL;
    }

    if( shp_index >= 0 && shp_index < gv_shapes_num_shapes(shapes)) {
        gv_shape = gv_shapes_get_shape(shapes, shp_index);
    }

    if( gv_shape == NULL ) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    SWIG_SimpleMakePtr( swig_shape_ptr, gv_shape, "_GvShape" );

    return Py_BuildValue("s", swig_shape_ptr );
}
%%
override gv_shapes_add_shape
static PyObject *
_wrap_gv_shapes_add_shape(PyGObject *self, PyObject *args)
{
    GvShapes *shapes;
    char     *swig_shape_ptr;
    int       shp_index = -1;
    GvShape   *gv_shape = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_shapes_add_shape", 
			  &swig_shape_ptr)) {
	return NULL;
    }

    shapes = GV_SHAPES(self->obj);
    if (!GV_IS_SHAPES(shapes)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvShapes");
	return NULL;
    }

    if( swig_shape_ptr )
    {
        gv_shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if (gv_shape) {
        shp_index = gv_shapes_add_shape(shapes, gv_shape);
    }

    return Py_BuildValue("i", shp_index );
}
%%
override gv_shapes_add_shape_last
static PyObject *
_wrap_gv_shapes_add_shape_last(PyGObject *self, PyObject *args)
{
    GvShapes *shapes;
    char     *swig_shape_ptr;
    int       shp_index = -1;
    GvShape   *gv_shape = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_shapes_add_shape_last",
                          &swig_shape_ptr) ) {
	return NULL;
    }

    shapes = GV_SHAPES(self->obj);
    if (!GV_IS_SHAPES(shapes)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvShapes");
	return NULL;
    }

    if( swig_shape_ptr ) {
        gv_shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
    }

    if (gv_shape) {
        shp_index = gv_shapes_add_shape_last(shapes, gv_shape);
    }

    return Py_BuildValue("i", shp_index );
}
%%
override gv_shapes_delete_shapes
static PyObject *
_wrap_gv_shapes_delete_shapes(PyGObject *self, PyObject *args)
{
    GvShapes *shapes = NULL;
    int       shape_count, ii;
    PyObject *pylist = NULL;
    int      *shape_ids = NULL;

    if (!PyArg_ParseTuple(args, "O!:gv_shapes_delete_shapes",
                          &PyList_Type, &pylist) ) {
	return NULL;
    }

    shapes = GV_SHAPES(self->obj);
    if (!GV_IS_SHAPES(shapes)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvShapes");
	return NULL;
    }

    shape_count = PyList_Size(pylist);
    shape_ids = g_new(int,shape_count);

    for( ii = 0; ii < shape_count; ii++ )
    {
        if( !PyArg_Parse( PyList_GET_ITEM(pylist,ii), "i", shape_ids + ii ) )
        {
        PyErr_SetString(PyExc_ValueError,
                       "expecting ints in gv_shapes_delete_shapes argument");
        return NULL;
        }
    }

    gv_shapes_delete_shapes( shapes, shape_count, shape_ids );

    g_free( shape_ids );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_shapes_replace_shapes
static PyObject *
_wrap_gv_shapes_replace_shapes(PyGObject *self, PyObject *args)
{
    GvShapes *shapes = NULL;
    int       shape_count, i;
    PyObject *pyindex_list = NULL, *pyshape_list = NULL;
    GvShape **shape_list = NULL;
    int      *shape_ids = NULL;
    int      copy_flag = FALSE;

    if (!PyArg_ParseTuple(args, "O!O!|d:gv_shapes_replace_shapes",
                          &PyList_Type, &pyindex_list,
                          &PyList_Type, &pyshape_list,
                          &copy_flag ) ) {
	return NULL;
    }

    shapes = GV_SHAPES(self->obj);
    if (!GV_IS_SHAPES(shapes)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvShapes");
	return NULL;
    }

    if( PyList_Size(pyindex_list) != PyList_Size(pyshape_list) )
    {
    PyErr_SetString(PyExc_RuntimeError,
          "Size of index & shape lists differ in gv_shapes_replace_shapes().");
    return NULL;
    }

    shape_count = PyList_Size(pyindex_list);
    shape_ids = g_new(int,shape_count);
    shape_list = g_new(GvShape*,shape_count);

    for( i = 0; i < shape_count; i++ )
    {
        char   *shape_swigid = NULL;

         if( !PyArg_Parse( PyList_GET_ITEM(pyindex_list,i), "i", shape_ids+i ))
        {
        PyErr_SetString(PyExc_ValueError,
                       "expecting ints in gv_shapes_replace_shapes argument");
        return NULL;
        }

        if( !PyArg_Parse( PyList_GET_ITEM(pyshape_list,i), "s",&shape_swigid ))
        {
        PyErr_SetString(PyExc_ValueError,
                    "expecting GvShape in gv_shapes_replace_shapes argument");
        return NULL;
        }

        shape_list[i] = SWIG_SimpleGetPtr( shape_swigid, "_GvShape" );
    }


    gv_shapes_replace_shapes( shapes, shape_count, shape_ids, shape_list,
                              copy_flag );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_shapes_get_extents
static PyObject *
_wrap_gv_shapes_get_extents(PyGObject *self, PyObject *args)
{
    GvRect rect;
    GvShapes *shapes;

    shapes = GV_SHAPES(self->obj);
    if (!GV_IS_SHAPES(shapes)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvShapes");
	return NULL;
    }

    gv_shapes_get_extents(shapes, &rect);

    return Py_BuildValue("(" CCCC ")", rect.x, rect.y, rect.width, rect.height);
}
%%
override gv_shapes_get_change_info
static PyObject *
_wrap_gv_shapes_get_change_info(PyObject *self, PyObject *args)
{
    GvShapeChangeInfo *change_info;
    PyObject *c_change_info;
    PyObject *id_list;
    int i;

    if (!PyArg_ParseTuple(args, "O:gv_shapes_get_change_info", &c_change_info))
    return NULL;

    if (!pygobject_check(c_change_info, &PyGPointer_Type))
        return NULL;

    change_info = pyg_pointer_get(c_change_info, GvShapeChangeInfo);

    id_list = PyTuple_New(change_info->num_shapes);

    for(i=0; i<change_info->num_shapes; i++)
    {
        PyTuple_SetItem(id_list, i, PyInt_FromLong((long)change_info->shape_id[i]));
    }

    return Py_BuildValue( "(iiO)",
                         change_info->change_type,
                         change_info->num_shapes,
                         id_list );
}
%%
override gv_points_get_point
static PyObject *
_wrap_gv_points_get_point(PyGObject *self, PyObject *args)
{
    PyGObject *py_points;
    GvPoints *points;
    GvPoint *point;
    int index;

    if (!PyArg_ParseTuple(args, "O!i:gv_points_get_point", &PyGvPoints_Type,
			  *py_points, &index)) {
        return NULL;
    }

    points = GV_POINTS(py_points->obj);
    if (!GV_IS_POINTS(points)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvPoints");
	return NULL;
    }

    if (index < 0 || index >= gv_points_num_points(points))
    {
        PyErr_SetString(PyExc_IndexError, "point index out of range");
        return NULL;
    }
    point = gv_points_get_point(points, index);
    return Py_BuildValue("(" CC ")", point->v.x, point->v.y);
}
%%
override gv_points_new_point
static PyObject *
_wrap_gv_points_new_point(PyGObject *self, PyObject *args)
{
    GvVertex vertex;
    GvPoints *points;

    if (!PyArg_ParseTuple(args, "(" CC "):gv_points_new_point",
			  &vertex.x, &vertex.y)) {
	return NULL;
    }

    points = GV_POINTS(self->obj);
    if (!GV_IS_POINTS(points)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvPoints");
	return NULL;
    }

    return PyInt_FromLong(gv_points_new_point(points, &vertex));
}
%%
override gv_polylines_get_line
static PyObject *
_wrap_gv_polylines_get_line(PyGObject *self, PyObject *args)
{
    PyGObject *py_pline; 
    GvPolylines *pline;
    int index;

    if (!PyArg_ParseTuple(args, "O!i:gv_polylines_get_line", &PyGvPolylines_Type,
			  &py_pline, &index)) {
	return NULL;
    }

    pline = GV_POLYLINES(py_pline->obj);
    if (!GV_IS_POLYLINES(pline)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvPolylines");
	return NULL;
    }

    if (index < 0 || index >= gv_polylines_num_lines(pline))
    {
	PyErr_SetString(PyExc_IndexError, "line index out of range");
	return NULL;
    }
    return build_py_line(gv_polylines_get_line(pline, index));
}
%%
override gv_areas_get_area
static PyObject *
_wrap_gv_areas_get_area(PyGObject *self, PyObject *args)
{
    PyGObject *py_areas;
    PyObject *pyarea;
    GvAreas *areas;
    GvArea *area;
    int index, ring;

    if (!PyArg_ParseTuple(args, "O!i:gv_areas_get_area", &PyGvAreas_Type,
			  &py_areas, &index)) {
	return NULL;
    }

    areas = GV_AREAS(py_areas->obj);
    if (!GV_IS_AREAS(areas)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvAreas");
	return NULL;
    }

    if (index < 0 || index >= gv_areas_num_areas(areas))
    {
	PyErr_SetString(PyExc_IndexError, "area index out of range");
	return NULL;
    }
    area = gv_areas_get_area(areas, index);

    pyarea = PyList_New(gv_areas_num_rings(area));
    for (ring = 0; ring < gv_areas_num_rings(area); ring++)
    {
        PyObject *pyline = build_py_line(gv_areas_get_ring(area, ring));
        PyList_SetItem(pyarea, ring, pyline);
    }
    return pyarea;
}
%%
override gv_shape_layer_set_color
static PyObject *
_wrap_gv_shape_layer_set_color(PyGObject *self, PyObject *args)
{
    GvShapeLayer *layer;
    GvColor color;

    if (!PyArg_ParseTuple(args, "(ffff):gv_shape_layer_set_color",
			  &color[0], &color[1], &color[2], &color[3])) {
	return NULL;
    }

    layer = GV_SHAPE_LAYER(self->obj);
    if (!GV_IS_SHAPE_LAYER(layer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvShapeLayer");
	return NULL;
    }

    gv_shape_layer_set_color(layer, color);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_shape_layer_get_selected
static PyObject *
_wrap_gv_shape_layer_get_selected(PyGObject *self, PyObject *args)
{
    GvShapeLayer *layer;
    PyObject  *list;
    GArray    *array;
    int       i;

    layer = GV_SHAPE_LAYER(self->obj);
    if (!GV_IS_SHAPE_LAYER(layer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvShapeLayer");
	return NULL;
    }

    array = g_array_new(FALSE,TRUE,sizeof(gint));
    gv_shape_layer_get_selected(layer, array);

    list = PyList_New(array->len);
    for( i = 0; i < array->len; i++ )
    {
        PyList_SetItem( list, i,
                        Py_BuildValue("i", g_array_index(array,gint,i)) );
    }

    g_array_free( array, TRUE );

    return list;
}
%%
override gv_shape_layer_pick_shape
static PyObject *
_wrap_gv_shape_layer_pick_shape( PyGObject *self, PyObject *args )
{
    PyGObject *py_view;
    GvShapeLayer *layer;
    GvViewArea *view;
    gint shape_id;
    float x, y;

    if (!PyArg_ParseTuple(args, "O!ff:gv_shape_layer_pick_shape",
                          &PyGvViewArea_Type, &py_view, &x, &y ))
    {
        return NULL;
    }

    layer = GV_SHAPE_LAYER(self->obj);
    if (!GV_IS_SHAPE_LAYER(layer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvShapeLayer");
	return NULL;
    }

    view = GV_VIEW_AREA(py_view->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }

    if (gv_shape_layer_pick_shape(layer, view, x, y, &shape_id )) {
        return PyInt_FromLong( (long)shape_id );
    }
    else
    {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gv_raster_new
static int
_wrap_gv_raster_new(PyGObject *self, PyObject *args, PyObject *keywds)
{
    PyObject * py_ret;
    char *filename = NULL, *dataset_string = NULL;
    GDALDatasetH  dataset;
    static int gdal_initialized = 0;
    GvSampleMethod sm = GvSMAverage;
    int   rband = 1;
    static char *kwlist[] = {"filename", "sample", "real",
                             "dataset", NULL};
    GvRaster *raster;

    if (!PyArg_ParseTupleAndKeywords(args, keywds, "|ziiz", kwlist,
                                     &filename, &sm, &rband,
                                     &dataset_string))
      return -1;

    if( !gdal_initialized )
    {
        GDALAllRegister();
        gdal_initialized = 1;
    }

    if( dataset_string != NULL )
    {
        dataset = (GDALDatasetH)
            SWIG_SimpleGetPtr(dataset_string, "GDALDatasetH" );
        if (dataset == NULL)
        {
            PyErr_SetString(PyExc_IOError,
                 "Unable to extract GDALDatasetH handle in gv_raster_new()");
            return -1;
        }
    }
    else if( filename != NULL )
    {
        dataset = GDALOpen( filename, GA_ReadOnly );

        if (dataset == NULL)
        {
            PyErr_SetString(PyExc_IOError, "failed to open data file");
            return -1;
        }

        GDALDereferenceDataset( dataset );
    }
    else
    {
        PyErr_SetString(PyExc_IOError,
                        "gv_raster_new: either a filename, or dataset handle"
                        " is required.  Neither provided." );
        return -1;
    }

    raster = GV_RASTER(gv_raster_new(dataset,rband,sm));
    if( filename != NULL )
        gv_data_set_name(GV_DATA(raster), filename);

    self->obj = (GObject *)raster;
    pygobject_register_wrapper((PyObject *)self);

    return 0;
    /* TEMP
    py_ret = PyGtk_New( G_OBJECT(raster) );
    gtk_object_sink( GTK_OBJECT(raster) );
    return py_ret;
    */
}
%%
override gv_raster_autoscale
static PyObject *
_wrap_gv_raster_autoscale(PyGObject *self, PyObject *args)

{
    int alg = GvASAAutomatic, assign = 0, success;
    double alg_param = -1.0;
    GvRaster *raster = NULL;
    double   out_min, out_max;

    if (!PyArg_ParseTuple(args, "idi:gv_raster_autoscale", 
                          &alg, &alg_param, &assign)) {
        return NULL;
    }

    raster = GV_RASTER(self->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    if( assign == 0 )
    {
        success = gv_raster_autoscale(raster, alg, alg_param, 0, NULL,
                                      NULL, NULL);
        if( !success )
        {
            PyErr_SetString(PyExc_RuntimeError,
                            "autoscale() failed, failed to get samples?" );
            return NULL;
        }

        return Py_BuildValue("(dd)", raster->min, raster->max);
    }
    else
    {
        success = gv_raster_autoscale(raster, alg, alg_param,
                                      0, NULL,
                                      &out_min, &out_max);

        if( !success )
        {
            PyErr_SetString(PyExc_RuntimeError,
                            "autoscale() failed, failed to get samples?" );
            return NULL;
        }

        return Py_BuildValue("(dd)", out_min, out_max );
    }
}
%%
override gv_raster_get_gdal_band
static PyObject *
_wrap_gv_raster_get_gdal_band(PyGObject *self, PyObject *args)
{
    PyGObject *py_raster;
    GvRaster *raster;
    char swig_ptr[32];
    GDALRasterBandH band;


    if (!PyArg_ParseTuple(args, "O!:gv_raster_get_gdal_band", &PyGvRaster_Type,
			  &py_raster)) {
	return NULL;
    }

    raster = GV_RASTER(py_raster->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    band = raster->gdal_band;

    if( band == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    SWIG_SimpleMakePtr( swig_ptr, band, "_GDALRasterBandH" );
    return Py_BuildValue("s",swig_ptr);
}
%%
override gv_raster_force_load
static PyObject *
_wrap_gv_raster_force_load(PyGObject *self, PyObject *args)
{
    PyGObject *py_raster;
    GvRaster *raster;
    int       i;

    if (!PyArg_ParseTuple(args, "O!:gv_raster_force_load", &PyGvRaster_Type,
			  &py_raster)) {
	return NULL;
    }

    raster = GV_RASTER(py_raster->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    for( i = 0; i < raster->max_tiles; i++ )
        gv_raster_tile_get( raster, i, 0 );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_raster_get_sample
static PyObject *
_wrap_gv_raster_get_sample(PyGObject *self, PyObject *args)
{
    GvRaster *raster;
    double x, y, real, imaginary;

    if (!PyArg_ParseTuple(args, "dd:gv_raster_get_sample",
			  &x, &y )) {
	return NULL;
    }

    raster = GV_RASTER(self->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    if( !gv_raster_get_sample(raster, x, y, &real, &imaginary ) )
        return NULL;
    else if( GDALDataTypeIsComplex(raster->gdal_type) )
        return Py_BuildValue( "(ff)", real, imaginary );
    else
        return Py_BuildValue( "f", real );
}
%%
override gv_raster_georef_to_pixel
static PyObject *
_wrap_gv_raster_georef_to_pixel(PyGObject *self, PyObject *args)
{
    GvRaster *raster;
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:gv_raster_georef_to_pixel", &x, &y )) {
	return NULL;
    }

    raster = GV_RASTER(self->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    if( gv_raster_georef_to_pixel(raster, &x, &y, NULL) )
    {
        return Py_BuildValue( "(ff)", x, y );
    }
    else
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "georef_to_pixel transformation failed." );
        return NULL;
    }
}
%%
override gv_raster_pixel_to_georef
static PyObject *
_wrap_gv_raster_pixel_to_georef(PyGObject *self, PyObject *args)
{
    GvRaster *raster;
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:gv_raster_pixel_to_georef",
			  &x, &y )) {
        return NULL;
    }

    raster = GV_RASTER(self->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    if( gv_raster_pixel_to_georef(raster, &x, &y, NULL ) )
    {
        return Py_BuildValue("(ff)", x, y);
    }
    else
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "georef_to_pixel transformation failed." );
        return NULL;
    }
}
%%
override gv_raster_georef_to_pixelCL
static PyObject *
_wrap_gv_raster_georef_to_pixelCL(PyGObject *self, PyObject *args)
{
    GvRaster *raster;
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:gv_raster_georef_to_pixelCL",
			  &x, &y )) {
	return NULL;
    }

    raster = GV_RASTER(self->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    if( gv_raster_georef_to_pixelCL(raster, &x, &y, NULL) )
    {
        return Py_BuildValue( "(ff)", x, y );
    }
    else
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "georef_to_pixelCL transformation failed." );
        return NULL;
    }
}
%%
override gv_raster_pixel_to_georefCL
static PyObject *
_wrap_gv_raster_pixel_to_georefCL(PyGObject *self, PyObject *args)
{
    GvRaster *raster;
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:gv_raster_pixel_to_georefCL",
			  &x, &y )) {
        return NULL;
    }

    raster = GV_RASTER(self->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    if( gv_raster_pixel_to_georefCL(raster, &x, &y, NULL ) )
    {
        return Py_BuildValue("(ff)", x, y);
    }
    else
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "georef_to_pixelCL transformation failed." );
        return NULL;
    }
}
%%
override gv_data_changing
static PyObject *
_wrap_gv_data_changing(PyGObject *self, PyObject *args)
{
    GvRaster *raster;
    int      x_off=0, y_off=0, width=0, height=0;
    GvRasterChangeInfo change_info;

    if (!PyArg_ParseTuple(args, "iiii:gv_data_changing",
			  &x_off, &y_off, &width, &height )) {
	return NULL;
    }

    if (GV_IS_RASTER(self->obj)) {
        raster = GV_RASTER(self->obj);

	if( height > 0 ) {
	    change_info.change_type = GV_CHANGE_REPLACE;
	    change_info.x_off = x_off;
	    change_info.y_off = y_off;
	    change_info.width = width;
	    change_info.height = height;

	    gv_data_changing( GV_DATA(raster), &change_info );
	}
	else {
	    gv_data_changing( GV_DATA(raster), NULL );
	}
    }
    else {
	PyErr_SetString(PyExc_TypeError, "argument must be a handled GvData type");
	return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_data_changed
static PyObject *
_wrap_gv_data_changed(PyGObject *self, PyObject *args)
{
    GvRaster *raster;
    GvData *data;
    int      x_off=0, y_off=0, width=0, height=0;
    GvRasterChangeInfo change_info;

    if (!PyArg_ParseTuple(args, "iiii:gv_data_changed",
			  &x_off, &y_off, &width, &height )) {
	return NULL;
    }

    if (GV_IS_RASTER(self->obj)) {
        raster = GV_RASTER(self->obj);

	if( height > 0 ) {
	    change_info.change_type = GV_CHANGE_REPLACE;
	    change_info.x_off = x_off;
	    change_info.y_off = y_off;
	    change_info.width = width;
	    change_info.height = height;

	    gv_data_changed( GV_DATA(raster), &change_info );
	}
	else {
	    gv_data_changed( GV_DATA(raster), NULL );
	}
    }
    else {
	data = GV_DATA(self->obj);
	if (!GV_IS_DATA(data)) {
	    PyErr_SetString(PyExc_TypeError, "data argument must be a GvData object");
	    return NULL;
	}
        gv_data_changed( GV_DATA(data), NULL );
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_raster_get_change_info
static PyObject *
_wrap_gv_raster_get_change_info(PyObject *self, PyObject *args)
{
    GvRasterChangeInfo *change_info;
    PyObject *c_change_info;

    if (!PyArg_ParseTuple(args, "O:gv_raster_get_change_info", &c_change_info))
    return NULL;

    if (!pygobject_check(c_change_info, &PyGPointer_Type))
        return NULL;

    change_info = pyg_pointer_get(c_change_info, GvRasterChangeInfo);

    return Py_BuildValue( "(iiiii)",
                          change_info->change_type,
                          change_info->x_off,
                          change_info->y_off,
                          change_info->width,
                          change_info->height
                         );
}
%%
override gv_raster_get_gcps
static PyObject *
_wrap_gv_raster_get_gcps(PyGObject *self, PyObject *args) {

    GvRaster *raster;
    const GDAL_GCP * pasGCPList;
    PyObject *psList;
    int iGCP;

    raster = GV_RASTER(self->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    pasGCPList = gv_raster_get_gcps( raster );

    psList = PyList_New(raster->gcp_count);
    for( iGCP = 0; pasGCPList != NULL && iGCP < raster->gcp_count; iGCP++)
    {
        PyObject *py_item;

        py_item = Py_BuildValue("(ssddddd)",
                                pasGCPList[iGCP].pszId,
                                pasGCPList[iGCP].pszInfo,
                                pasGCPList[iGCP].dfGCPPixel,
                                pasGCPList[iGCP].dfGCPLine,
                                pasGCPList[iGCP].dfGCPX,
                                pasGCPList[iGCP].dfGCPY,
                                pasGCPList[iGCP].dfGCPZ );
    PyList_SetItem(psList, iGCP, py_item );
    }

    return psList;
}
%%
override gv_raster_set_gcps
static PyObject *
_wrap_gv_raster_set_gcps(PyGObject *self, PyObject *args) {

    GvRaster *raster;
    GDAL_GCP *pasGCPList;
    PyObject *psList;
    int iGCP, nGCPCount, success;

    if (!PyArg_ParseTuple(args,"O!:gv_raster_set_gcps",
                         &PyList_Type, &psList)) {
        return NULL;
    }

    raster = GV_RASTER(self->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    nGCPCount = PyList_Size(psList);
    pasGCPList = (GDAL_GCP *) CPLCalloc(sizeof(GDAL_GCP),nGCPCount);
    GDALInitGCPs( nGCPCount, pasGCPList );

    for( iGCP = 0; iGCP < nGCPCount; iGCP++ )
    {
        char *pszId = NULL, *pszInfo = NULL;

    if( !PyArg_Parse( PyList_GET_ITEM(psList,iGCP), "(ssddddd)",
                      &pszId, &pszInfo,
                      &(pasGCPList[iGCP].dfGCPPixel),
                      &(pasGCPList[iGCP].dfGCPLine),
                      &(pasGCPList[iGCP].dfGCPX),
                      &(pasGCPList[iGCP].dfGCPY),
                      &(pasGCPList[iGCP].dfGCPZ) ) )
        {
        PyErr_SetString(PyExc_ValueError, "improper GCP tuple");
        return NULL;
        }

        CPLFree( pasGCPList[iGCP].pszId );
    pasGCPList[iGCP].pszId = CPLStrdup(pszId);
        CPLFree( pasGCPList[iGCP].pszInfo );
    pasGCPList[iGCP].pszInfo = CPLStrdup(pszInfo);
    }

    success = gv_raster_set_gcps( raster, nGCPCount, pasGCPList );

    GDALDeinitGCPs( nGCPCount, pasGCPList );
    CPLFree( pasGCPList );

    return Py_BuildValue("d", success);
}
%%
override gv_raster_get_gcpsCL
static PyObject *
_wrap_gv_raster_get_gcpsCL(PyGObject *self, PyObject *args) {

    GvRaster *raster;
    const GDAL_GCP * pasGCPList;
    PyObject *psList;
    int iGCP;

    raster = GV_RASTER(self->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    pasGCPList = gv_raster_get_gcpsCL( raster );

    psList = PyList_New(raster->gcp_countCL);
    for( iGCP = 0; pasGCPList != NULL && iGCP < raster->gcp_countCL; iGCP++)
    {
        PyObject *py_item;

        py_item = Py_BuildValue("(ssddddd)",
                                pasGCPList[iGCP].pszId,
                                pasGCPList[iGCP].pszInfo,
                                pasGCPList[iGCP].dfGCPPixel,
                                pasGCPList[iGCP].dfGCPLine,
                                pasGCPList[iGCP].dfGCPX,
                                pasGCPList[iGCP].dfGCPY,
                                pasGCPList[iGCP].dfGCPZ );
	PyList_SetItem(psList, iGCP, py_item );
    }

    return psList;
}
%%
override gv_raster_set_gcpsCL
static PyObject *
_wrap_gv_raster_set_gcpsCL(PyGObject *self, PyObject *args) {

    GvRaster *raster;
    GDAL_GCP *pasGCPList;
    PyObject *psList;
    int iGCP, nGCPCount, success, poly_order;

    if (!PyArg_ParseTuple(args,"O!i:gv_raster_set_gcpsCL",
			  &PyList_Type, &psList,
			  &poly_order)) {
        return NULL;
    }

    raster = GV_RASTER(self->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    nGCPCount = PyList_Size(psList);
    pasGCPList = (GDAL_GCP *) CPLCalloc(sizeof(GDAL_GCP),nGCPCount);
    GDALInitGCPs( nGCPCount, pasGCPList );

    for( iGCP = 0; iGCP < nGCPCount; iGCP++ )
    {
        char *pszId = NULL, *pszInfo = NULL;

    if( !PyArg_Parse( PyList_GET_ITEM(psList,iGCP), "(ssddddd)",
                      &pszId, &pszInfo,
                      &(pasGCPList[iGCP].dfGCPPixel),
                      &(pasGCPList[iGCP].dfGCPLine),
                      &(pasGCPList[iGCP].dfGCPX),
                      &(pasGCPList[iGCP].dfGCPY),
                      &(pasGCPList[iGCP].dfGCPZ) ) )
        {
        PyErr_SetString(PyExc_ValueError, "improper GCP tuple");
        return NULL;
        }

        CPLFree( pasGCPList[iGCP].pszId );
    pasGCPList[iGCP].pszId = CPLStrdup(pszId);
        CPLFree( pasGCPList[iGCP].pszInfo );
    pasGCPList[iGCP].pszInfo = CPLStrdup(pszInfo);
    }

    success = gv_raster_set_gcpsCL( raster, nGCPCount, pasGCPList,poly_order);

    GDALDeinitGCPs( nGCPCount, pasGCPList );
    CPLFree( pasGCPList );

    return Py_BuildValue("d", success);
}

%%
override gv_raster_layer_new
static int
_wrap_gv_raster_layer_new(PyGObject *self, PyObject *args)
{
    PyObject *py_properties = NULL;
    PyGObject *py_raster;
    GvRaster *raster;
    GvRasterLayer *layer;
    GvProperties properties = NULL;
    int      mode = GV_RLM_AUTO;

    if (!PyArg_ParseTuple(args, "O!|iO!:gv_raster_layer_new", &PyGvRaster_Type,
			  &py_raster, &mode, &PyList_Type, &py_properties )) {
	return -1;
    }

    raster = GV_RASTER(py_raster->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return -1;
    }

    if( py_properties != NULL )
    {
        int     i;

        for( i = 0; i < PyList_Size(py_properties); i++ )
        {
            char *name, *value;
            PyObject *tuple = PyList_GET_ITEM(py_properties, i);

            if (!PyArg_ParseTuple(tuple, "ss", &name, &value))
            {
                PyErr_SetString(PyExc_ValueError, "properties format");
                return -1;
            }

            gv_properties_set( &properties, name, value );
        }
    }

    layer = GV_RASTER_LAYER(gv_raster_layer_new( mode, raster, properties ));

    gv_properties_destroy( &properties );

    self->obj = (GObject *)layer;
    pygobject_register_wrapper((PyObject *)self);

    return 0;
}
%%
override gv_raster_layer_autoscale_view
static PyObject *
_wrap_gv_raster_layer_autoscale_view(PyGObject *self, PyObject *args)

{
    int alg = GvASAAutomatic, isrc = 0, success;
    double alg_param = -1.0;
    GvRasterLayer *rlayer = NULL;
    double   out_min, out_max;

    if (!PyArg_ParseTuple(args, "idi:gv_raster_layer_autoscale_view",
                          &alg, &alg_param, &isrc)) {
        return NULL;
    }

    rlayer = GV_RASTER_LAYER(self->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    success = gv_raster_layer_autoscale_view(rlayer, isrc, alg, alg_param,
                                             &out_min, &out_max );
    if( !success )
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "autoscale() failed, failed to get samples?" );
        return NULL;
    }

    return Py_BuildValue("(dd)", out_min, out_max );
}
%%
override gv_raster_layer_get_mesh_lod
static PyObject *
_wrap_gv_raster_layer_get_mesh_lod(PyGObject *self, PyObject *args)

{
    PyGObject *py_rlayer = NULL;
    GvRasterLayer *rlayer = NULL;

    if (!PyArg_ParseTuple(args, "O!:gv_raster_get_mesh_lod",
			  &PyGvRasterLayer_Type, &py_rlayer)) {
	return NULL;
    }

    rlayer = GV_RASTER_LAYER(py_rlayer->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    return Py_BuildValue("i", rlayer->mesh->detail );
}
%%
override gv_raster_layer_histogram_view
static PyObject *
_wrap_gv_raster_layer_histogram_view(PyGObject *self, PyObject *args)

{
    PyObject *py_list;
    GvRasterLayer *rlayer = NULL;
    double   scale_min, scale_max;
    int      hist_size = 256, isrc = 0, hist_count, i;
    int      *histogram = NULL;

    if (!PyArg_ParseTuple(args, "iddi:gv_raster_layer_histogram_view",
                          &isrc, &scale_min, &scale_max, &hist_size)) {
        return NULL;
    }

    rlayer = GV_RASTER_LAYER(self->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    histogram = g_new(int, hist_size);

    hist_count =
        gv_raster_layer_histogram_view(rlayer, isrc,
                                       scale_min, scale_max, TRUE,
                                       hist_size, histogram );
    if( hist_count == 0 )
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "histogram() failed, failed to get samples?" );
        return NULL;
    }

    py_list = PyList_New(0);
    for( i = 0; i < hist_size; i++ )
    {
        PyObject *py_value = Py_BuildValue("i", histogram[i]);
        PyList_Append(py_list, py_value);
        Py_DECREF( py_value );
    }
    g_free( histogram );

    return py_list;
}
%%
override gv_raster_layer_view_to_pixel
static PyObject *
_wrap_gv_raster_layer_view_to_pixel(PyGObject *self, PyObject *args)
{
    GvRasterLayer *rlayer;
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:gv_raster_layer_view_to_pixel",
			  &x, &y )) {
	return NULL;
    }

    rlayer = GV_RASTER_LAYER(self->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    if( gv_raster_layer_view_to_pixel(rlayer, &x, &y, NULL ) )
    {
        return Py_BuildValue("(ff)", x, y);
    }
    else
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "view_to_pixel transformation failed." );
        return NULL;
    }
}
%%
override gv_raster_layer_pixel_to_view
static PyObject *
_wrap_gv_raster_layer_pixel_to_view(PyGObject *self, PyObject *args)
{
    GvRasterLayer *rlayer;
    double x, y;

    if (!PyArg_ParseTuple(args, "dd:gv_raster_layer_pixel_to_view",
			  &x, &y )) {
	return NULL;
    }

    rlayer = GV_RASTER_LAYER(self->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    if( gv_raster_layer_pixel_to_view(rlayer, &x, &y, NULL ) )
    {
        return Py_BuildValue("(ff)", x, y);
    }
    else
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "pixel_to_view transformation failed." );
        return NULL;
    }
}
%%
override gv_raster_layer_set_source
static PyObject *
_wrap_gv_raster_layer_set_source( PyGObject *self, PyObject *args)
{
    PyGObject *py_raster;
    GvRasterLayer *rlayer;
    GvRaster *raster = NULL;
    char *lut = NULL;
    int isource, const_value, ret, lut_len=0, nodata_active=FALSE;
    float min, max;
    PyObject *nodata = NULL;
    float nodata_real=-1e8, nodata_imaginary=0.0;

    if (!PyArg_ParseTuple( args, "iOffi|z#O:gv_raster_layer_set_source",
                           &isource, &py_raster, &min, &max,
                           &const_value, &lut, &lut_len, &nodata )) {
	return NULL;
    }

    rlayer = GV_RASTER_LAYER(self->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    if( py_raster == NULL || py_raster == Py_None )
        raster = NULL;
    else if (PyObject_TypeCheck(py_raster, &PyGvRaster_Type))
        raster = GV_RASTER(py_raster->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "2nd argument must be a GvRaster");
        return NULL;
    }

    if( nodata == NULL || nodata == Py_None )
    {
        nodata_real = 0.0;
        nodata_imaginary = 0.0;
        nodata_active = FALSE;
    }
    else if( PyTuple_Check(nodata) )
    {
        if( !PyArg_ParseTuple( nodata, "ff", &nodata_real, &nodata_imaginary) )
            return NULL;

        nodata_active = TRUE;
    }
    else
    {
        if( !PyArg_Parse( nodata, "f", &nodata_real ) )
            return NULL;

        nodata_imaginary = 0.0;
        nodata_active = TRUE;
    }

    ret = gv_raster_layer_set_source(rlayer,
				     isource, raster,
				     min, max, const_value, lut,
				     nodata_active,
				     nodata_real, nodata_imaginary );

    return Py_BuildValue("i", ret);
}
%%
override gv_raster_layer_texture_mode_set
static PyObject *
_wrap_gv_raster_layer_texture_mode_set(PyGObject *self, PyObject *args)
{
    GvRasterLayer *rlayer;
    int texture_mode;
    GvColor color;

    if (!PyArg_ParseTuple(args, "i(ffff):gv_raster_layer_texture_mode_set",
			  &texture_mode,
			  &color[0], &color[1], &color[2], &color[3])) {
	return NULL;
    }

    rlayer = GV_RASTER_LAYER(self->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    return PyInt_FromLong(gv_raster_layer_texture_mode_set(rlayer,
							   texture_mode, color));
}
%%
override gv_raster_layer_texture_mode_get
static PyObject *
_wrap_gv_raster_layer_texture_mode_get( PyGObject *self, PyObject *args)
{
    GvRasterLayer *rlayer;
    int texture_mode;
    GvColor color;
    PyObject *py_color, *py_retval;

    rlayer = GV_RASTER_LAYER(self->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    if (gv_raster_layer_texture_mode_get(rlayer, &texture_mode, &color ))
    {
	Py_INCREF(Py_None);
	return Py_None;
    } else {
	py_color = Py_BuildValue( "(ffff)", color[0], color[1], color[2], color[3] );
	py_retval = Py_BuildValue( "(iO)", texture_mode, py_color );
	Py_DECREF( py_color );
	return py_retval;
    }
}
%%
override gv_raster_layer_alpha_get
static PyObject *
_wrap_gv_raster_layer_alpha_get(PyGObject *self, PyObject *args)
{
    GvRasterLayer *rlayer;
    float alpha_val;
    int alpha_mode;

    rlayer = GV_RASTER_LAYER(self->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    if (gv_raster_layer_alpha_get(rlayer, &alpha_mode, &alpha_val ))
    {
	Py_INCREF(Py_None);
	return Py_None;
    } else {
	return Py_BuildValue("(if)", alpha_mode, alpha_val );
    }
}
%%
override gv_raster_layer_blend_mode_get
static PyObject *
_wrap_gv_raster_layer_blend_mode_get( PyGObject *self, PyObject *args)
{
    GvRasterLayer *rlayer;
    int blend_mode;
    int sfactor;
    int dfactor;

    rlayer = GV_RASTER_LAYER(self->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    if (gv_raster_layer_blend_mode_get(rlayer, &blend_mode, &sfactor, &dfactor ))
    {
	Py_INCREF(Py_None);
	return Py_None;
    } else {
	return Py_BuildValue("(iii)", blend_mode, sfactor, dfactor );
    }
}
%%
override gv_raster_layer_lut_get
static PyObject *
_wrap_gv_raster_layer_lut_get( PyGObject *self, PyObject *args)
{
    GvRasterLayer *rlayer;
    PyObject *py_lut, *py_retval;
    char *lut;
    int width, height;
    int rgba_complex=0;

    if (!PyArg_ParseTuple( args, "|i:gv_raster_layer_lut_get",
                           &rgba_complex )) {
        return NULL;
    }

    rlayer = GV_RASTER_LAYER(self->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    lut = gv_raster_layer_lut_get(rlayer, &width, &height, rgba_complex );
    if (lut == NULL)
    {
        Py_INCREF(Py_None);
        return Py_None;
    } else {
	py_lut = PyString_FromStringAndSize( lut, width * height * 4 );
        if ( py_lut == NULL )
        {
            Py_INCREF(Py_None);
            return Py_None;
        }

        py_retval = Py_BuildValue( "(Oii)", py_lut, width, height );
        Py_DECREF( py_lut );
        return py_retval;
    }
}
%%
override gv_raster_layer_nodata_get
static PyObject *
_wrap_gv_raster_layer_nodata_get( PyGObject *self, PyObject *args)
{
    GvRasterLayer *rlayer;
    int isource = 0;
    gint ret;
    double nodata_real, nodata_imaginary;

    if (!PyArg_ParseTuple( args, "i:gv_raster_layer_nodata_get",
                           &isource )) {
        return NULL;
    }

    rlayer = GV_RASTER_LAYER(self->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    ret = gv_raster_layer_nodata_get( rlayer, isource,
                                      &nodata_real, &nodata_imaginary );
    if( ret )
    {
        if( GDALDataTypeIsComplex(gv_raster_layer_type_get(rlayer, isource)) )
            return Py_BuildValue( "(ff)", nodata_real, nodata_imaginary );
        else
            return Py_BuildValue( "f", nodata_real );
    }
    else
    {
        Py_INCREF( Py_None );
        return Py_None;
    }
}
%%
override gv_raster_layer_get_nodata
static PyObject *
_wrap_gv_raster_layer_get_nodata(PyGObject *self, PyObject *args)
{
    PyGObject *py_rlayer;
    GvRasterLayer *rlayer;
    int isource=0;

    if (!PyArg_ParseTuple(args, "O!i:gv_raster_layer_get_nodata",
			  &PyGvRasterLayer_Type, &py_rlayer, &isource)) {
	return NULL;
    }

    rlayer = GV_RASTER_LAYER(py_rlayer->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    if( rlayer != NULL && isource >= 0 && isource < rlayer->source_count )
    {
        GvRasterSource *source = rlayer->source_list + isource;

        if( source->nodata_active && source->data != NULL
            && source->data->gdal_type == GDT_CFloat32 )
            return Py_BuildValue( "(ff)", source->nodata_real,
                                  source->nodata_imaginary );
        else
            return Py_BuildValue( "f", source->nodata_real );
    }
    else
    {
        Py_INCREF( Py_None );
        return Py_None;
    }
}
%%
override gv_raster_layer_get_source_lut
static PyObject *
_wrap_gv_raster_layer_get_source_lut(PyGObject *self, PyObject *args)
{
    PyGObject *py_rlayer;
    GvRasterLayer *rlayer;
    PyObject *py_lut;
    char *lut;
    int isource=0;

    if (!PyArg_ParseTuple(args, "O!i:gv_raster_layer_get_source_lut",
			  &PyGvRasterLayer_Type, &py_rlayer, &isource)) {
	return NULL;
    }

    rlayer = GV_RASTER_LAYER(py_rlayer->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    lut = gv_raster_layer_source_get_lut(rlayer, isource);
    if( lut == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    if ( ( py_lut = PyString_FromStringAndSize( lut, 256 ) ) == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return py_lut;
}
%%
override gv_raster_layer_zoom_get
static PyObject *
_wrap_gv_raster_layer_zoom_get( PyGObject *self, PyObject *args)
{
    GvRasterLayer *rlayer;
    int mag, min;

    rlayer = GV_RASTER_LAYER(self->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    if( gv_raster_layer_zoom_get(rlayer, &mag, &min ) )
    {
	Py_INCREF(Py_None);
	return Py_None;
    } else {
	return Py_BuildValue( "(ii)", min, mag );
    }
}
%%
override gv_raster_layer_get_height
static PyObject *
_wrap_gv_raster_layer_get_height(PyGObject *self, PyObject *args)
{
    PyGObject *py_rlayer;
    GvRasterLayer *rlayer;
    double x, y, result;
    int success;

    if (!PyArg_ParseTuple(args, "O!dd:gv_raster_layer_get_height",
			  &PyGvRasterLayer_Type, &py_rlayer, &x, &y )) {
	return NULL;
    }

    rlayer = GV_RASTER_LAYER(py_rlayer->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    result = gv_mesh_get_height(rlayer->mesh, x, y, &success );
    if( success ) {
        return Py_BuildValue("f", result );
    }
    PyErr_SetString(PyExc_RuntimeError, "gv_mesh_get_height failed." );
    return NULL;
}
%%
override gv_manager_get_preferences
static PyObject *
_wrap_gv_manager_get_preferences(PyGObject *self, PyObject *args)
{
    GvManager *manager;
    GvProperties *properties = NULL;
    PyObject *psDict = NULL;

    manager = GV_MANAGER(self->obj);
    if (!GV_IS_MANAGER(manager)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvManager");
	return NULL;
    }

    properties = gv_manager_get_preferences(manager);

    psDict = PyDict_New();
    if( properties != NULL )
    {
        int        i, count;

        count = gv_properties_count( properties );
        for( i = 0; i < count; i++ )
        {
            const char *value, *name;
            PyObject *py_name, *py_value;

            value = gv_properties_get_value_by_index(properties,i);
            name = gv_properties_get_name_by_index(properties,i);

            py_name = Py_BuildValue("s",name);
            py_value = Py_BuildValue("s",value);
            PyDict_SetItem( psDict, py_name, py_value );

            Py_DECREF(py_name);
            Py_DECREF(py_value);
        }
    }

    return psDict;
}
%%
override gv_manager_add_dataset
static PyObject *
_wrap_gv_manager_add_dataset(PyGObject *self, PyObject *args)
{
    char *dataset_string=NULL;
    char swig_ptr[32];
    GDALDatasetH dataset = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_manager_add_dataset",
                          &dataset_string)) {
        return NULL;
    }

    dataset = (GDALDatasetH) SWIG_SimpleGetPtr(dataset_string, "GDALDatasetH");
    if( dataset == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    dataset = gv_manager_add_dataset(GV_MANAGER(self->obj), dataset);
    SWIG_SimpleMakePtr(swig_ptr, dataset, "_GDALDatasetH");
    return Py_BuildValue("s", swig_ptr);
}
%%
override gv_manager_get_dataset
static PyObject *
_wrap_gv_manager_get_dataset(PyGObject *self, PyObject *args)
{
    char *filename = NULL;
    char swig_ptr[32];
    GDALDatasetH dataset = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_manager_get_dataset",
                         &filename)) {
        return NULL;
    }

    dataset = gv_manager_get_dataset(GV_MANAGER(self->obj), filename);

    if( dataset == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }
    else
    {
        SWIG_SimpleMakePtr(swig_ptr, dataset, "_GDALDatasetH");
        return Py_BuildValue("s", swig_ptr);
    }
}
%%
override gv_manager_get_dataset_raster
static PyObject *
_wrap_gv_manager_get_dataset_raster(PyGObject *self, PyObject *args)
{
    char *dataset_string=NULL;
    int band = 0;
    GDALDatasetH dataset = NULL;
    GvRaster *raster = NULL;

    if (!PyArg_ParseTuple(args, "si:gv_manager_get_dataset_raster",
                          &dataset_string, &band)) {
        return NULL;
    }

    dataset = (GDALDatasetH) SWIG_SimpleGetPtr(dataset_string, "GDALDatasetH");
    if( dataset == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    raster = gv_manager_get_dataset_raster(GV_MANAGER(self->obj), dataset, band);

    if( raster == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }
    else
    {
        return PyGtk_New((GObject*)raster);
    }
}
%%
override gv_manager_queue_task
static PyObject *
_wrap_gv_manager_queue_task(PyGObject *self, PyObject *args)
{
    GvManager *manager;
    int       priority;
    char      *task_name;
    PyTaskData *psProgressInfo;

    psProgressInfo = g_new(PyTaskData,1);
    psProgressInfo->psPyCallback = NULL;
    psProgressInfo->psPyCallbackData = Py_None;

    if (!PyArg_ParseTuple(args, "siO|O:gv_manager_queue_task",
                          &task_name, &priority,
                          &(psProgressInfo->psPyCallback),
                          &(psProgressInfo->psPyCallbackData) ) ) {
	return NULL;
    }

    manager = GV_MANAGER(self->obj);
    if (!GV_IS_MANAGER(manager)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvManager");
	return NULL;
    }

    if( manager == NULL )
    {
        Py_INCREF(Py_None);
        return Py_None;
    }

    Py_XINCREF( psProgressInfo->psPyCallback );
    Py_XINCREF( psProgressInfo->psPyCallbackData );

    psProgressInfo->psThreadState = PyThreadState_Get();

    gv_manager_queue_task(manager,
			  task_name, priority,
			  PyIdleTaskProxy,
			  psProgressInfo );

    Py_INCREF(Py_None);

    return Py_None;
}
%%
override gv_rgba_to_rgb
static PyObject *
_wrap_gv_rgba_to_rgb(PyObject *self, PyObject *args)
{
    PyObject *rgba_obj = NULL;
    PyObject *rgb_obj = NULL;
    const char *rgba;
    char       *rgb;
    int length, i;

    if (!PyArg_ParseTuple(args, "O!:gv_rgba_to_rgb",
                          &PyString_Type, &rgba_obj))
    return NULL;

    length = PyString_Size( rgba_obj ) / 4;
    rgba = PyString_AS_STRING( rgba_obj );

    rgb = (char *) malloc(length*3);

    for( i = 0; i < length; i++ )
    {
        rgb[i*3  ] = rgba[i*4  ];
        rgb[i*3+1] = rgba[i*4+1];
        rgb[i*3+2] = rgba[i*4+2];
    }

    rgb_obj = PyString_FromStringAndSize( rgb, length * 3 );

    free( rgb );

    return rgb_obj;
}
%%
override WIDInterpolate
static PyObject *
_wrap_WIDInterpolate(PyObject *self, PyObject *args)
{
    PyObject *poPyPoints;
    PyProgressData sProgressInfo;
    char *pszSwigBand = NULL;
    int nPoints, i, nErr;
    double *padfXYVW;
    double fExponent;
    GDALRasterBandH hBand;

    sProgressInfo.psPyCallback = NULL;
    sProgressInfo.psPyCallbackData = NULL;

    if (!PyArg_ParseTuple(args, "O!s|dOO:WIDInterpolate",
                          &PyList_Type, &poPyPoints,
                          &pszSwigBand,
                          &fExponent,
                          &(sProgressInfo.psPyCallback),
                          &(sProgressInfo.psPyCallbackData) ) )
    return NULL;

    hBand = (GDALRasterBandH)
        SWIG_SimpleGetPtr(pszSwigBand, "_GDALRasterBandH" );

    if( hBand == NULL )
    {
        PyErr_SetString( PyExc_ValueError,
                         "Couldn't parse GDALRasterBandH argument." );
        return NULL;
    }

    nPoints = PyList_Size(poPyPoints);
    padfXYVW = g_new(double,4*nPoints);
    for( i = 0; i < nPoints; i++ )
    {
        if( !PyArg_Parse( PyList_GET_ITEM(poPyPoints,i), "(dddd)",
                          padfXYVW + i + 0*nPoints,
                          padfXYVW + i + 1*nPoints,
                          padfXYVW + i + 2*nPoints,
                          padfXYVW + i + 3*nPoints ) )
        {
            g_free( padfXYVW );
        PyErr_SetString(PyExc_ValueError,
                            "bad point format (x,y,value,weight)" );
            return NULL;
        }
    }

    nErr = WIDInterpolate( nPoints, padfXYVW, padfXYVW+nPoints,
                           padfXYVW+nPoints*2, padfXYVW+nPoints*3, hBand,
                           fExponent, PyProgressProxy, &sProgressInfo );

    g_free( padfXYVW );

    return Py_BuildValue( "i", nErr );
}
%%
override gv_raster_rasterize_shapes
static PyObject *
_wrap_gv_raster_rasterize_shapes(PyGObject *self, PyObject *args)
{
    PyObject *py_shapelist;
    GvRaster *raster;
    double   burn_value;
    int      shape_count, i, ret_value, fill_short = 1;
    GvShape  **shape_list;

    if (!PyArg_ParseTuple(args, "O!di:gv_raster_rasterize_shapes",
			  &PyList_Type, &py_shapelist,
                          &burn_value, &fill_short)) {
	return NULL;
    }

    raster = GV_RASTER(self->obj);
    if (!GV_IS_RASTER(raster)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRaster");
	return NULL;
    }

    shape_count = PyList_Size(py_shapelist);
    shape_list = g_new(GvShape*,shape_count);
    for( i = 0; i < shape_count; i++ )
    {
        GvShape *gv_shape;
        char *swig_shape_ptr;

        if( !PyArg_Parse( PyList_GET_ITEM(py_shapelist,i), "s",
                          &swig_shape_ptr) )
        {
            g_free( shape_list );
            PyErr_SetString( PyExc_ValueError,
                             "bad item in shapelist" );
            return NULL;
        }
        gv_shape = SWIG_SimpleGetPtr( swig_shape_ptr, "_GvShape" );
        if( gv_shape == NULL )
        {
            g_free( shape_list );
            PyErr_SetString( PyExc_ValueError,
                             "bad item in shapelist(2)" );
            return NULL;
        }

        shape_list[i] = gv_shape;
    }

    ret_value = gv_raster_rasterize_shapes( raster, shape_count, shape_list,
                                            burn_value, fill_short );

    return Py_BuildValue( "i", ret_value );
}
%%
override gtk_color_well_get_d

static PyObject * _wrap_gtk_color_well_get_d( PyGObject *self, PyObject *args)
{
    PyObject *py_color_well;
    GtkColorWell *color_well;
    gdouble r, g, b, a;

    color_well = GTK_COLOR_WELL(self->obj);
    if (!GTK_IS_COLOR_WELL(color_well)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GtkColorWell");
	return NULL;
    }

    gtk_color_well_get_d(color_well, &r, &g, &b, &a );

    return Py_BuildValue( "(dddd)", r, g, b, a );
}
%%
override gv_view_area_format_point_query
static PyObject *_wrap_gv_view_area_format_point_query( PyGObject *self, PyObject *args )
{
    gdouble x, y;
    char *text;
    GvViewArea *view = NULL;
    GvManager *manager;

    if (!PyArg_ParseTuple( args, "dd:gv_view_area_format_point_query", &x, &y )) {
        return NULL;
    }

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea object");
	return NULL;
    }

    manager = gv_get_manager();

    text = (char *) gv_view_area_format_point_query( view, &(manager->preferences), x, y );

    return Py_BuildValue( "s", text );
}
%%
override MyGDALOperator
static PyObject *
_wrap_MyGDALOperator(PyObject *self, PyObject *args)
{
    char *pszSwigDS1 = NULL;
    char *pszSwigDS2 = NULL;
    GDALDatasetH hDS1 = NULL, hDS2 = NULL;
    int  nErr = 1;

    if (!PyArg_ParseTuple(args, "ss:MyGDALOperator",
                          &pszSwigDS1, &pszSwigDS2 ) )
        return NULL;

    hDS1 = (GDALDatasetH) SWIG_SimpleGetPtr(pszSwigDS1, "_GDALDatasetH" );
    hDS2 = (GDALDatasetH) SWIG_SimpleGetPtr(pszSwigDS2, "_GDALDatasetH" );

    if( hDS1 != NULL && hDS2 != NULL )
    {
        /* do something with hDS1 and hDS2 */
        printf( "%s -> %s\n",
                GDALGetDescription( hDS1 ),
                GDALGetDescription( hDS2 ) );
        nErr = 0;
    }

    return Py_BuildValue( "i", nErr );
}
%%
override gv_symbol_manager_save_vector_symbol
static PyObject *
_wrap_gv_symbol_manager_save_vector_symbol(PyGObject *self, PyObject *args)
{
    GvSymbolManager *manager;
    char     *symbol_name = NULL, *new_name = NULL;

    if (!PyArg_ParseTuple(args, "ss:gv_symbol_manager_save_vector_symbol",
                          &symbol_name, &new_name )) {
        return NULL;
    }

    manager = GV_SYMBOL_MANAGER(self->obj);
    if (!GV_IS_SYMBOL_MANAGER(manager)) {
	PyErr_SetString(PyExc_TypeError, "manager argument must be a GvSymbolManager");
	return NULL;
    }

    if( symbol_name && new_name )
    {
        if (gv_symbol_manager_save_vector_symbol(manager, symbol_name, new_name))
        {
            Py_INCREF(Py_None);
            return Py_None;
        }
        else
        {
            PyErr_SetString(PyExc_TypeError,
                "error while saving new symbol in gv_symbol_manager_save_vector_symbol()." );
        return NULL;
        }
    }

    return NULL;
}
%%
override gv_view_area_create_thumbnail
static PyObject *
_wrap_gv_view_area_create_thumbnail(PyGObject *self, PyObject *args)
{
#ifndef PENDING_GTK2
    PyErr_SetString(PyExc_RuntimeError, "not supported on this platform");
    return NULL;
#else

    GvViewArea *view;
    PyGObject *py_layer;
    PyObject *ret;
    GvLayer *layer;
    GdkPixmap *pixmap;
    int width, height;

    if (!PyArg_ParseTuple(args, "O!ii:gv_view_area_create_thumbnail",
			  &PyGvLayer_Type, &py_layer, &width, &height)) {
	return NULL;
    }

    view = GV_VIEW_AREA(self->obj);
    if (!GV_IS_VIEW_AREA(view)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvViewArea");
	return NULL;
    }
    layer = GV_LAYER(py_layer->obj);
    if (!GV_IS_LAYER(layer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvLayer");
	return NULL;
    }

    pixmap = gv_view_area_create_thumbnail(view, layer, width, height);
    if (!pixmap) {
        PyErr_SetString(PyExc_RuntimeError, "could not create pixmap");
        return NULL;
    }
    ret = PyGdkWindow_New(pixmap);
    gdk_pixmap_unref(pixmap);
    return ret;
#endif
}
%%
override gv_polylines_new_line
static PyObject *
_wrap_gv_polylines_new_line(PyGObject *self, PyObject *args)
{
    PyObject *pylist;
    GvPolylines *pline;
    GArray *line;
    int index;

    if (!PyArg_ParseTuple(args, "O!:gv_polylines_new_line",
			  &PyList_Type, &pylist)) {
	return NULL;
    }

    pline = GV_POLYLINES(self->obj);
    if (!GV_IS_POLYLINES(pline)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvPolylines");
	return NULL;
    }

    line = build_gv_line(pylist, 2);
    if (!line) return NULL;
    index = gv_polylines_new_line_with_data(pline, 
					    line->len, (GvVertex*)line->data);
    g_array_free(line, TRUE);
    return PyInt_FromLong(index);
}
%%
override gv_areas_new_area
static PyObject *
_wrap_gv_areas_new_area(PyGObject *self, PyObject *args)
{
    PyObject *pyarea;
    GvAreas *areas;
    GvArea *area;
    int index, ring, num_rings;

    if (!PyArg_ParseTuple(args, "O!:gv_areas_new_area",
			  &PyList_Type, &pyarea)) {
	return NULL;
    }

    areas = GV_AREAS(self->obj);
    if (!GV_IS_AREAS(areas)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvAreas");
	return NULL;
    }

    num_rings = PyList_Size(pyarea);
    if (num_rings < 1)
    {
	PyErr_SetString(PyExc_ValueError, "empty ring list");
	return NULL;
    }

    area = gv_area_new(FALSE);
    for (ring = 0; ring < num_rings; ring++)
    {
	GArray *line = build_gv_line(PyList_GET_ITEM(pyarea, ring), 3);
	if (!line) break;
	g_ptr_array_add(area->rings, line);
    }
    if (PyErr_Occurred())
    {
	gv_area_delete(area);
	return NULL;
    }

    index = gv_areas_new_area_with_data(areas, area);
    gv_area_delete(area);
    return PyInt_FromLong(index);
}
%%
override gv_raster_layer_lut_put
static PyObject *
_wrap_gv_raster_layer_lut_put( PyGObject *self, PyObject *args)
{
    GvRasterLayer *rlayer;
    char *lut;
    int  lut_len, height;

    if (!PyArg_ParseTuple( args, "z#:gv_raster_layer_lut_put",
			   &lut, &lut_len )) {
	return NULL;
    }

    rlayer = GV_RASTER_LAYER(self->obj);
    if (!GV_IS_RASTER_LAYER(rlayer)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvRasterLayer");
	return NULL;
    }

    if( lut != NULL && lut_len != 1024 && lut_len != 1024 * 256 )
    {
     PyErr_SetString(PyExc_TypeError,
       "lut string must be 256x1x4 or 256x256x4 in gv_raster_layer_lut_put");
     return NULL;
    }

    height = lut_len / 1024;
    gv_raster_layer_lut_put(rlayer, lut, height );

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gv_launch_url
static PyObject *
_wrap_gv_launch_url(PyObject *self, PyObject *args)
{
    char *url = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_launch_url", &url))
    return NULL;

    return Py_BuildValue("i",gv_launch_url(url));
}
%%
override gv_short_path_name
static PyObject * _wrap_gv_short_path_name(PyObject *self, PyObject *args)
{
    char *lpszLongPath = NULL;
    PyObject * result = NULL;

    if (!PyArg_ParseTuple(args, "s:gv_short_path_name",
                          &lpszLongPath))
        return NULL;

    result = Py_BuildValue("s",gv_short_path_name(lpszLongPath));

    //invalid path in lpszLongPath results in zero length string
    if (PyString_Size(result) == 0)
    {
        PyErr_Format(PyExc_OSError, "path (%s) does not exist.", lpszLongPath);
        return NULL;
    }

    return result;
}
%%
override gv_shapes_to_dbf
static PyObject *_wrap_gv_shapes_to_dbf(PyObject *self, PyObject *args) {
    PyGObject *py_data;
    GvData *data;
    char *filename;

    if (!PyArg_ParseTuple(args, "sO!:gv_shapes_to_dbf", &filename, &PyGvData_Type, &py_data)) {
        return NULL;
    }

    data = GV_DATA(py_data->obj);
    if (!GV_IS_DATA(data)) {
	PyErr_SetString(PyExc_TypeError, "argument must be a GvData object");
	return NULL;
    }

    return PyInt_FromLong(gv_shapes_to_dbf(filename, data));
}
%%
override gv_shapes_layer_new
static int
_wrap_gv_shapes_layer_new(PyGObject *self, PyObject *args)
{
    PyGObject *shapes = NULL;
    GvShapes *shapes_obj = NULL;

    if (!PyArg_ParseTuple(args, "|O:shapes_layer_new", &shapes)) {
        return -1;
    }

    /* ---- Get shapes or NULL ---- */
    if ((shapes == NULL) || ((PyObject*)shapes == Py_None)) {
        shapes_obj = NULL;
    }
    else if (PyObject_TypeCheck(shapes, &PyGvShapes_Type)) {
        shapes_obj = (GvShapes*) shapes->obj;
    }
    else {
        PyErr_SetString(PyExc_ValueError, "Incorrect shapes argument type");
        return -1;
    }

    /* ---- Create new layer with shapes ---- */
    self->obj = (GObject *)gv_shapes_layer_new(shapes_obj);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GvShapesLayer object");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gv_pquery_layer_new
static int
_wrap_gv_pquery_layer_new(PyGObject *self, PyObject *args)
{
    PyGObject *shapes = NULL;
    GvShapes *shapes_obj = NULL;

    if (!PyArg_ParseTuple(args, "|O:pquery_layer_new", &shapes)) {
        return -1;
    }

    /* ---- Get shapes or NULL ---- */
    if ((shapes == NULL) || ((PyObject*)shapes == Py_None)) {
        shapes_obj = NULL;
    }
    else if (PyObject_TypeCheck(shapes, &PyGvShapes_Type)) {
        shapes_obj = (GvShapes*) shapes->obj;
    }
    else {
        PyErr_SetString(PyExc_ValueError, "Incorrect shapes argument type");
        return -1;
    }

    /* ---- Create new layer with shapes ---- */
    self->obj = (GObject *)gv_pquery_layer_new(shapes_obj);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GvPqueryLayer object");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gv_point_layer_new
static int
_wrap_gv_point_layer_new(PyGObject *self, PyObject *args)
{
    PyGObject *shapes = NULL;
    GvPoints *points_obj = NULL;

    if (!PyArg_ParseTuple(args, "|O:point_layer_new", &shapes)) {
        return -1;
    }

    /* ---- Get shapes or NULL ---- */
    if ((shapes == NULL) || ((PyObject*)shapes == Py_None)) {
        points_obj = NULL;
    }
    else if (PyObject_TypeCheck(shapes, &PyGvPoints_Type)) {
        points_obj = (GvPoints*) shapes->obj;
    }
    else {
        PyErr_SetString(PyExc_ValueError, "Incorrect shapes argument type");
        return -1;
    }

    /* ---- Create new layer with shapes ---- */
    self->obj = (GObject *)gv_point_layer_new(points_obj);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GvPointLayer object");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gv_areas_layer_new
static int
_wrap_gv_areas_layer_new(PyGObject *self, PyObject *args)
{
    PyGObject *shapes = NULL;
    GvAreas *areas_obj = NULL;

    if (!PyArg_ParseTuple(args, "|O:areas_layer_new", &shapes)) {
        return -1;
    }

    /* ---- Get shapes or NULL ---- */
    if ((shapes == NULL) || ((PyObject*)shapes == Py_None)) {
        areas_obj = NULL;
    }
    else if (PyObject_TypeCheck(shapes, &PyGvAreas_Type)) {
        areas_obj = (GvAreas*) shapes->obj;
    }
    else {
        PyErr_SetString(PyExc_ValueError, "Incorrect shapes argument type");
        return -1;
    }

    /* ---- Create new layer with shapes ---- */
    self->obj = (GObject *)gv_areas_layer_new(areas_obj);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GvAreasLayer object");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gv_line_layer_new
static int
_wrap_gv_line_layer_new(PyGObject *self, PyObject *args)
{
    PyGObject *shapes = NULL;
    GvPolylines *lines_obj = NULL;

    if (!PyArg_ParseTuple(args, "|O:line_layer_new", &shapes)) {
        return -1;
    }

    /* ---- Get shapes or NULL ---- */
    if ((shapes == NULL) || ((PyObject*)shapes == Py_None)) {
        lines_obj = NULL;
    }
    else if (PyObject_TypeCheck(shapes, &PyGvPolylines_Type)) {
        lines_obj = (GvPolylines*) shapes->obj;
    }
    else {
        PyErr_SetString(PyExc_ValueError, "Incorrect shapes argument type");
        return -1;
    }

    /* ---- Create new layer with shapes ---- */
    self->obj = (GObject *)gv_line_layer_new(lines_obj);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GvLineLayer object");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gv_app_cur_layer_new
static int
_wrap_gv_app_cur_layer_new(PyGObject *self, PyObject *args)
{
    PyGObject *shapes = NULL;
    GvShapes *shapes_obj = NULL;

    if (!PyArg_ParseTuple(args, "|O:app_cur_layer_new", &shapes)) {
        return -1;
    }

    /* ---- Get shapes or NULL ---- */
    if ((shapes == NULL) || ((PyObject*)shapes == Py_None)) {
        shapes_obj = NULL;
    }
    else if (PyObject_TypeCheck(shapes, &PyGvShapes_Type)) {
        shapes_obj = (GvShapes*) shapes->obj;
    }
    else {
        PyErr_SetString(PyExc_ValueError, "Incorrect shapes argument type");
        return -1;
    }

    /* ---- Create new layer with shapes ---- */
    self->obj = (GObject *)gv_app_cur_layer_new(shapes_obj);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create AppCurLayer object");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
